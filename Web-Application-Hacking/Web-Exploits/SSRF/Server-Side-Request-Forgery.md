# Server-Side Request Forgery

Server-Side Request Forgery (SSRF), [PortSwigger](https://portswigger.net/web-security/ssrf) states: *"is a web security vulnerability that allows an attacker to cause the server-side application to make requests to an unintended location."*

Impact:
- Access data within an organisation
- Potential arbitrary command execution

- Types
	- Reflected
		- Cause an application to issue a back-end HTTP request to a supplied URL and then the response from the back-end request is returned in the application's front-end response
	- Blind 
		- *Cause an application to issue a back-end HTTP request to a supplied URL, but the response from the back-end request is not returned in the application's front-end response*?
		- Note from [Portswigger](https://portswigger.net/web-security/ssrf/blind) *It is common when testing for SSRF vulnerabilities to observe a DNS look-up for the supplied Collaborator domain, but no subsequent HTTP request. This typically happens because the application attempted to make an HTTP request to the domain, which caused the initial DNS lookup, but the actual HTTP request was blocked by network-level filtering. It is relatively common for infrastructure to allow outbound DNS traffic, since this is needed for so many purposes, but block HTTP connections to unexpected destinations.*
		- Techniques:
			- Use out-of-band techniques = attempt to trigger an HTTP request to an external system that you control
				- `python3 -m http.server 80` or beware DNS blacklisting!
				- `BurpSuite Collaborator`
			- *Explore content on systems that the application server can reach*, because their is DNS blacklisting
				- blindly sweep the internal IP address space
			- *Induce the application to connect to a system under the attacker's control, and return malicious responses to the HTTP client that makes the connection.* RCEs!	 
- Locale	
	- Affecting the local server
		- Why implicitly trust request that come directly from the local machine:
			- *The [access control](https://portswigger.net/web-security/access-control) check might be implemented in a different component that sits in front of the application server. When a connection is made back to the server, the check is bypassed.*
			- Disaster recovery may require administrative access without authentication from the local machine
				- Assumption of trust the user would come directly from the server
			- Administrative interface might listen on a different port to the main application - not reachable directly by users. 
	- Affecting back-end systems
		- Protected by network topology (often non-routable private IP address), but weaker security posture
- Indicators:
	- Full URL used in a parameter in address bar
	- Hidden field in a form
	- Partial URL as just a `hostname`
	- Path of a URL 
- Bypassing SSRF defences
	- SSRF Blacklist-based input filters
		- Alternate IP representations
		- Registering a domain that resolves to `127.0.0.1` - `spoofed.burpcollaborator.net`
		- Obfuscate blocked strings using URL encoding, case variation
		- Provide a controlled URL that redirects to the target URL
			- Try different:
				- Redirection codes
				- Protocols 
	- SSRF Whitelist-based input filters 
		- Combinations of or singularly (exploitation of inconsistencies in URL):
			- Embedded credentials using `@`
			- URL fragments `#` `https://url#expected-host`
			- Leverage DNS naming hierarchy with controlled FQDN `https://expected-host.evil-host`
			- URL encoding characters to confuse the URL-parsing code (especially if there is asymmetry in how the filter handles URL encoded characters to the code that executes the back-end request)
				- Double encoding
	- SSRF Bypassing filter via [open redirect](https://learn.snyk.io/lesson/open-redirect/) a *vulnerability occurs when an application allows a user to control a redirect or forward to another URL*
		- API used to make the back-end HTTP request supports redirection 
		- The parameter has to actually redirect, because the 
		- Construct a URL that satisfies the filter to then redirected to your defined destination
- Hidden Attack Surface
	- Partial URLs in requests
		- Some *applications places only a hostname or part of a URL path into request parameters.*
			- *However full SSRF might be limited because you do not control the entire URL that gets requested.*	-
		- URLs within data formats
			- Some applications transmit data in formats with a specification that allows the inclusion of URLs that might get requested by the data parser for the format.
			- examples: 
				- SSRF to reach an XML parser to perform [[XXE-Injection]] 
				- SSRF via  [[XXE-Injection]] if URL is modifiable within the XML 
	- SSRF via Referrer header
		- *Some applications use server-side analytics software to tracks visitors. This software often logs the Referrer header in requests, so it can track incoming links. Often the analytics software visits any third-party URLs that appear in the Referrer header.*


## Considerations

- Access sensitive files
- Portsweep internal services on `127.0.0.1`
- Attack services through the SSRF with another vulnerability 

- By Language:
	- PHP
		- [[Useful_PHP]] - [[PHP-Filters]] including `file:///filepath/to/file.php` to 
		- In combination [[File-Inclusion]] if `include()` is used

## Mitigation

- Deny List
- Allow List
- Open redirect 

## References

[PortSwigger SSRF](https://portswigger.net/web-security/ssrf) 
[PortSwigger Access Control](https://portswigger.net/web-security/access-control)
[THM Room SSRF](https://tryhackme.com/room/ssrfqi)
[Snyk open redirect](https://learn.snyk.io/lesson/open-redirect/) 
[Portswigger](https://portswigger.net/web-security/ssrf/blind)