# Windows Escalation Vectors Enumeration
This article contain manual enumeration commands and methods to potential find a a vector of escalation. For vectors of privilege escalation see [[Windows-Privilege-Escalation-Vectors]]

## General Enumeration:
```powershell
$ExecutionContext.SessionState.LanguageMode # Contrained langauage mode?
$str = 'amsiinitfailed' # Is Amsi up?
# AV Whitelisted  
reg query "HKLM\SOFTWARE\Microsoft\Windows Defender\Exclusions\Paths"
# Check commands if in limited shell
get-command # Then get-alias

ver                            # get version
echo %PROCESSOR_ARCHITECTURE%  # Evasive way of bit info
tasklist /svc                  # list all services
tasklist /m                    # list all processes and dlls
systeminfo                     # list system information
get-computerinfo           # ps version of systeminfo
hostname                       #
vssadmin                       # volume shadow copy service admin # need admin may one day be useful
wmic qfe get Caption,Description,HotFixId,InstalledOn           # Patch level!
wmic qfe list                  # LIST patch history!!!
$PSVersionTable.PSVersion
# Environment variables
dir env: # if set breaks your shell
set                

# Critical in find insecurity in file system and chain vectors
icacls $dirsAndFilesAndEVERYTHING # Permissions are everything
cacls

# Processes - consider context of your position to what is running
get-process
# scheduledtask
get-scheduledtask | findstr /v Disabled

dir /A                         # Hidden files, never use just dir  
ls -hidden
Get-ChildItem -Hidden -Path    # String in hidden files 
findstr /si string *.extension # find patterns from current directory and recursively

Get-ChildItem -Path C:\ -Include *.doc,*.[FILETYPE] -File -Recurse -ErrorAction SilentlyContinue # Find files with powershell

# Get ACTUAL %PATH% variables instead of set!
reg query "HKLM\System\CurrentControlSet\Session Management\Environment"
# set and setx no are accurate


# Drives!
wmic logicaldisk get caption || fsutil fsinfo drives
wmic logicaldisk get caption,description,providername
Get-PSDrive | where {$_.Provider -like "Microsoft.PowerShell.Core\FileSystem"}| ft Name,Root
```


## User and Group Enumeration
```powershell
whoami /priv
net account # Logon requirements
net user # "" insert user name if required with quotes 
get-netuser | out-gridview
get-netuser | select -expandproperty lastlogon
(Get-NetUser).name
Get-LocalUser -Name "Administrator" | Select Name,SID
# Logged in
query user /server:$SERVER
net group "administrators" # /domain
# Users Sessions
quser
qwinsta 
```

## ConsoleHost history file:
```powershell
type %userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt

(Get-PSReadlineOption).HistorySavePath
```

## Important Windows Locations
[[PrivEsc-Important-Windows-Locations]]

## Insecure World Writable Files and  Directories 

**THIS IS FREQUENT CHAINING OF INSECURITIES - OWNSHIP AND INTERACTABILITY ARE CRITICAL TO EVERYTHING ICACLS IS YOU BEST FRIEND**
You are looking for with  `icacls` either a directory or tree of directories due to Windows Pathing for locating executables:
- Write/Add file
- Delete permission + search path or anywhere else on search path. 
```powershell
icacls.exe

Get-ChildItem "C:\Program Files" -Recurse | Get-ACL | ?{$_.AccessToString -match "Everyone\sAllow\s\sModify"}

accesschk.exe -uws "Everyone" "C:\Program Files"
accesschk.exe -uwdqs "Users" "c:\*" /accepteula
accesschk.exe -uwdqs "Authenticated Users" "c:\*" /accepteula
accesschk.exe -uwdqs "Everyone" "c:\*" /accepteula
accesschk.exe -uwqs "Users" * /accepteula
accesschk.exe -uwqs "Authenticated Users" * /accepteula
accesschk.exe -uwqs "Everyone" * /accepteula

icacls "C:\Program Files\*" 2>nul | findstr "(F)" | findstr "Everyone"
icacls "C:\Program Files (x86)\*" 2>nul | findstr "(F)" | findstr "Everyone"
icacls "C:\Program Files\*" 2>nul | findstr "(F)" | findstr "BUILTIN\Users"
icacls "C:\Program Files (x86)\*" 2>nul | findstr "(F)" | findstr "BUILTIN\Users"
icacls "C:\Program Files\*" 2>nul | findstr "(M)" | findstr "Everyone"
icacls "C:\Program Files (x86)\*" 2>nul | findstr "(M)" | findstr "Everyone"
icacls "C:\Program Files\*" 2>nul | findstr "(M)" | findstr "BUILTIN\Users"
icacls "C:\Program Files (x86)\*" 2>nul | findstr "(M)" | findstr "BUILTIN\Users"
icacls "C:\Documents and Settings\*" 2>nul | findstr "(F)" | findstr "Everyone"
icacls "C:\Documents and Settings\*" 2>nul | findstr "(M)" | findstr "Everyone"
icacls "C:\Documents and Settings\*" 2>nul | findstr "(F)" | findstr "BUILTIN\Users"
icacls "C:\Documents and Settings\*" 2>nul | findstr "(M)" | findstr "BUILTIN\Users"
icacls "C:\Users\*" 2>nul | findstr "(F)" | findstr "Everyone"
icacls "C:\Users\*" 2>nul | findstr "(F)" | findstr "BUILTIN\Users"
icacls "C:\Users\*" 2>nul | findstr "(M)" | findstr "Everyone"
icacls "C:\Users\*" 2>nul | findstr "(M)" | findstr "BUILTIN\Users"
icacls "C:\Documents and Settings\*" /T 2>nul | findstr ":F" | findstr "BUILTIN\Users"
icacls "C:\Users\*" /T 2>nul | findstr ":F" | findstr "BUILTIN\Users"
echo.
# (cacls for older versions of Windows)
cacls "C:\Program Files\*" 2>nul | findstr "(F)" | findstr "Everyone"
cacls "C:\Program Files (x86)\*" 2>nul | findstr "(F)" | findstr "Everyone"
cacls "C:\Program Files\*" 2>nul | findstr "(F)" | findstr "BUILTIN\Users"
cacls "C:\Program Files (x86)\*" 2>nul | findstr "(F)" | findstr "BUILTIN\Users"
cacls "C:\Program Files\*" 2>nul | findstr "(M)" | findstr "Everyone"
cacls "C:\Program Files (x86)\*" 2>nul | findstr "(M)" | findstr "Everyone"
cacls "C:\Program Files\*" 2>nul | findstr "(M)" | findstr "BUILTIN\Users"
cacls "C:\Program Files (x86)\*" 2>nul | findstr "(M)" | findstr "BUILTIN\Users"
cacls "C:\Documents and Settings\*" 2>nul | findstr "(F)" | findstr "Everyone"
cacls "C:\Documents and Settings\*" 2>nul | findstr "(M)" | findstr "Everyone"
cacls "C:\Documents and Settings\*" 2>nul | findstr "(F)" | findstr "BUILTIN\Users"
cacls "C:\Documents and Settings\*" 2>nul | findstr "(M)" | findstr "BUILTIN\Users"
cacls "C:\Users\*" 2>nul | findstr "(F)" | findstr "Everyone"
cacls "C:\Users\*" 2>nul | findstr "(F)" | findstr "BUILTIN\Users"
cacls "C:\Users\*" 2>nul | findstr "(M)" | findstr "Everyone"
cacls "C:\Users\*" 2>nul | findstr "(M)" | findstr "BUILTIN\Users"
cacls "C:\Documents and Settings\*" /T 2>nul | findstr ":F" | findstr "BUILTIN\Users"
cacls "C:\Users\*" /T 2>nul | findstr ":F" | findstr "BUILTIN\Users"
```


## Device Driver and Kernel Modules Queries
```powershell
driverquery
sc query windefend # requires NAME use get-ciminstance here for memory
sc queryex type=service
get-ciminstance -namespace root/securitycenter2 -classname antivirusproduct

driverquery.exe /v /fo csv | ConvertFrom-CSV | Select-Object ‘Display Name’, ‘Start Mode’, Path

Get-WmiObject Win32_PnPSignedDriver | Select-Object DeviceName, DriverVersion, Manufacturer | Where-Object {$_.DeviceName -like "*$SOMETHING*"}
```

## Network Enumeration
```powershell
Get-NetComputer -ping
# check dns server
ipconfig /all                                    
Get-NetIPConfiguration | ft InterfaceAlias,InterfaceDescription,IPv4Address
Get-DnsClientServerAddress -AddressFamily IPv4 | ft

# -a displays all active connections, -n prevents name resolution, -o display the pid for each connection
netstat -ano 

# ARP Table
arp -a
Get-NetNeighbor -AddressFamily IPv4 | ft ifIndex,IPAddress,LinkLayerAddress,State

# Network shares
net share
powershell Find-DomainShare -ComputerDomain domain.local

# List routing table
route print
Get-NetRoute -AddressFamily IPv4 | ft DestinationPrefix,NextHop,RouteMetric,ifIndex

# SNMP Configuration
reg query HKLM\SYSTEM\CurrentControlSet\Services\SNMP /s
Get-ChildItem -path HKLM:\SYSTEM\CurrentControlSet\Services\SNMP -Recurse

1..15 | %(echo "10.10.10.$_"; ping -n 1 10.10.10.$_ | Select-String tt1)         # ip ping sweep 
1..1024 | %(echo ((New-Object Net.Sockets.TcpCLient).Connect("10.10.10.10", $_)) "Open port on - $_" 2>$null # Port scan
```

## Hotfix levels
```powershell
get-hotfix
get-hotfix | format-list | findstr InstalledOn
get-hotfix | format-table hotfixid
get-hotfix -ID  # specific information

wmic product get name, version, vendor
wmic qfe get Caption, Description, HotFixID, InstalledOn
```

## Unmounted Disks
```powershell
mountvol
```

## Host Sercurity Enumeration
[`GetCimInstance`](https://docs.microsoft.com/en-us/powershell/module/cimcmdlets/get-ciminstance?view=powershell-7.2) maybe configured to not be avaliable for non-users, but may end up needing them to pivot through a network after inital PrivEsc.

Firewalls enumeration powershell
```powershell
Get-NetFirewallProfile | Format-Table Name, Enabled
# Tear down the WALL
Set-NetFirewallProfile -Profile Domain, Public, Private -Enable False
# Show rules
Get-NetfirewallRule | select Display, Enabled, Description
```
and with cmd.exe:
```powershell
netsh advfirewall firewall dump
# or 
netsh firewall show state
netsh firewall show config
# advfirewall
netsh advfirewall firewall show rule name=all
```
Testing a firewall from the inside:
```powershell
Test-NetConnection -ComputerName 127.0.0.1 -Port 80
```

List all block ports by firewall
```powershell
$f=New-object -comObject HNetCfg.FwPolicy2;$f.rules |  where {$_.action -eq "0"} | select name,applicationname,localports
```

Disable firewall
```powershell
# Disable Firewall on Windows 7 via cmd
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server"  /v fDenyTSConnections /t REG_DWORD /d 0 /f

# Disable Firewall on Windows 7 via Powershell
powershell.exe -ExecutionPolicy Bypass -command 'Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server" -Name "fDenyTSConnections" –Value'`

# Disable Firewall on any windows via cmd
netsh firewall set opmode disable
netsh Advfirewall set allprofiles state off
```

Eventlogs sometimes provide an insight into applications and services, security or otherwise
```powershell 
Get-EventLog -List
```

Windows Defender
```powershell 
Get-Service WinDefend
# Check Windows Defender Enabled but have
Get-MpComputerStatus | Select RealTimeProtectionEnabled 
Set-MpPreference -DisableRealtimeMonitoring $true

# Registry Key
HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows Defender

sc stop WinDefend
sc start WinDefend

# check status of Defender
PS C:\> Get-MpComputerStatus

# disable scanning all downloaded files and attachments, disable AMSI (reactive)
PS C:\> Set-MpPreference -DisableRealtimeMonitoring $true; Get-MpComputerStatus
PS C:\> Set-MpPreference -DisableIOAVProtection $true

# disable AMSI (set to 0 to enable)
PS C:\> Set-MpPreference -DisableScriptScanning 1 

# exclude a folder
PS C:\> Add-MpPreference -ExclusionPath "C:\Temp"
PS C:\> Add-MpPreference -ExclusionPath "C:\Windows\Tasks"
PS C:\> Set-MpPreference -ExclusionProcess "word.exe", "vmwp.exe"

# remove signatures (if Internet connection is present, they will be downloaded again):
PS > & "C:\ProgramData\Microsoft\Windows Defender\Platform\4.18.2008.9-0\MpCmdRun.exe" -RemoveDefinitions -All
PS > & "C:\Program Files\Windows Defender\MpCmdRun.exe" -RemoveDefinitions -All
```

AV
```powershell
wmic / :\\ \  path antivirusproduct
Get-CimInstance -Namespace <name/space> -ClassName AntivirusProduct
WMIC /Node:localhost /Namespace:\\root\SecurityCenter2 Path AntivirusProduct Get displayName
```

Sysmon Enumeration
```powershell
Get-CimInstance win32_service -Filter "Description = 'System Monitor service'"
Get-Service | where-object {$_.DisplayName -like "*sysm*"}
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Channels\Microsoft-Windows-Sysmon\Operational
```
If you find Sysmon, find the config file.
```powershell
 findstr /si '<ProcessCreate onmatch="exclude">' C:\* # BEWARE recursive searching!
```

## WMI-Obejcts
```powershell
Get-WmiObject win32_useraccount | Select name,sid
gvmi win32_userprofile
#Get Computer system information
Get-WMIObject Win32_ComputerSystem
#Get Computer name from available System information
Get-WMIObject Win32_ComputerSystem| Select-Object -ExpandProperty Name
#Get Domain name from available System Information
Get-WMIObject Win32_ComputerSystem| Select-Object -ExpandProperty Domain

net localgroup # "" insert group name if required with quotes
Get-Net-Group
Get-NetGroupMember "Domain Admins"
Get-NetUsers -Domain

get-netdomaincontroller

cmdkey /list # Saved Creds!
runas /savecred /user:<user> cmd.exe
```

## Software
```powershell
get-executionpolicy -list
set-executionpolicy bypass -scope process # Change executionpolicy
wmic product get name,version,vendor
wmic service list brief
wmic service list brief | findstr  "Running"
sc qc <service>
```

## AppLocker

```powershell
# List AppLocker Rules
# Requires Powerview
PowerView PS C:\> Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections
```

## Services
```powershell
tasklist /v /fi "username eq system"
wmic service where "name like 'InsecureProcess'" get Name, PathName
Get-Process -Name <name>
# Network Service Enumeration
netstat -noa |findstr "LISTENING"|finder "<ProcessID>"
get-service
restart-service

# Remove service dependceny
sc config $service depend= ""

```

Wmic available
```powershell
for /f "tokens=2 delims='='" %a in ('wmic service list full^|find /i "pathname"^|find /i /v "system32"') do @echo %a >> c:\windows\temp\permissions.txt

for /f eol^=^"^ delims^=^" %a in (c:\windows\temp\permissions.txt) do cmd.exe /c icacls "%a"
```
Wmic unavaliable
```powershell
sc query state= all | findstr "SERVICE_NAME:" >> Servicenames.txt
FOR /F %i in (Servicenames.txt) DO echo %i
type Servicenames.txt
FOR /F "tokens=2 delims= " %i in (Servicenames.txt) DO @echo %i >> services.txt
FOR /F %i in (services.txt) DO @sc qc %i | findstr "BINARY_PATH_NAME" >> path.txt
```

## Registery
[Register keys]([[Windows-Registry]] ) have permissions, but register values do not have permissions. Values are inheirated from keys, subkeys if value or key has control of execution of a privileged process has write permissions we run code with elevated permissions. Always perform subkey inherence check. Not very stealth more so than use Powershell, but effective.

```powershell
reg query "HKLM\System\CurrentControlSet\Session Management\Environment"
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU /f password /t REG_SZ /s
reg query HKCU\Software\Microsoft\Windows\CurrentVersion\Run
reg query HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
reg query "HKCU\Software\ORL\WinVNC3\Password" # VNC credentials
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" # Putty clear text proxy credentials
reg query HKEY_LOCAL_MACHINE\SOFTWARE\RealVNC\WinVNC4 /v password
reg query HKLM /f password /t REG_SZ /s
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\R
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon" 2>nul | findstr "DefaultUserName DefaultDomainName DefaultPassword"
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon" # Windows Autologin
reg query HKLM\SYSTEM\CurrentControlSet\Control\Lsa
reg query HKLM\SYSTEM\CurrentControlSet\Services\NTDS\Parameters /v "DSA Database file"
reg query HKLM\SYSTEM\CurrentControlSet\Services\SNMP /s
reg query "HKLM\SYSTEM\Current\ControlSet\Services\SNMP" # SNMP parameters
```

DNS Zone Transfer with `nslookup`
```
nslookup.exe
>server IP 
>ls -d domainname.com
```

## References

[THM Windows PrivEsc Room](https://tryhackme.com/room/windowsprivesc20)
[THM Lay of the Land Room](https://tryhackme.com/room/thelayoftheland)
[Hacktricks](https://book.hacktricks.xyz/windows-hardening/windows-local-privilege-escalation/privilege-escalation-abusing-tokens)
[PayloadsAllTheThings - Windows Privilege Escalation](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md)
[Wild west hackin' Fest Jake Williams - Talk: Elevating your Windows Privilege like Boss](https://www.youtube.com/watch?v=SHdM197sbIE')
[Wild west hackin' Fest Jake Williams - Talk: Privilege Escalation](https://www.youtube.com/watch?v=yXe4X-AIbps)
[Udemy - tib3rius](https://www.udemy.com/user/tib3rius/)
[Fareedfauzi](https://fareedfauzi.gitbook.io/oscp-notes/windows-post-exploitation/windows-privesc-technique)