# Fixing Exploits

1. Alway read the Exploit code before initial use
2. Check the shellcode is not destructive
3. Get the dependencies! Remember to check [https://github.com/offensive-security/exploitdb-bin-sploits](https://github.com/offensive-security/exploitdb-bin-sploits) - exploit write there own for various reasons
4. Sometimes modifications are needed for the different context than a some stated Public Exploits
5. Refactoring Exploits to another language to make use of a library or feature of the language 
6. [0xdf](https://0xdf.gitlab.io/2019/03/05/htb-devel.html) : *"Precompiled exploits require keyboard access or remote desktop."*
7. Generate your payload, shellcode, etc. Reversing can come with its own riskes to your machines and time.

## Refactoring Considerations

- Separately test code block or change at a time.
- Keep backups at various stages - be your own simple github locally, save yourself work re-re-coding something.  
- Good documentation is key to reading code, but code like its documentation - good naming, does one thing well, limit input and output amount to functions, [[Refactoring]].
- What is the exploit's controlflow, map out visual step by step, any input handling or checks just simplify with branch `checks x`,  do not get bogged down in details, till review. 
- Architecture - replicate target environment [[Virtual-Machines]] with all your [[Reverse-Engineering-Tools]]
- How each language handles strings, buffers, memory allocation.

## Compilation Considerations

- Indications by library as where and how the exploit was originally compiled.
- Get a cross compiler `mingw-64 cross-compiler`.
- Beware of compile wanting to be safe.

## Garbage Collector Considerations

## Memory Consideration
Recreate target environment locally with a VM and use  debugger to detirmine memory related considerations. Otherwise we have to really on public knowledge. `msfpescan` exists, but so does Radare2 (see [[Radare2-Cheatsheet]] and [[Radare2-Commands]] and [[Ghidra-Cheatsheet]]

## Fixing Memory Corruption Exploits

## Stack based exploits

#### Without  Memory Corrupt Protection
Exploit:
1. Create a large buffer to store payload and prime the memory corruption
2. Hijack EIP with padding til offset to overwrite a return address on stack
3. Add an optional prepended NOP sled to the payload
4. JMP `REGISTER` (ESP,...) to redirect the execution flow to the beginning address onf the payload on the stack.

Prefixing:
1. Best and healthy practice to locate return address personally, not trust the exploit code.
2. May just be best to exclude obvious bad characters
3. Check the endianness of hardware and exploit code!

Fixes/Modification considerations:
1. Any additions retraction alter the offset! Add or remove padding to accommodate additional variables like File paths, IP addresses, ports, URLs, etc.
2. Payload may need to modification or replacing **AGAIN** adjust for size changes, general bes to replace entirely for safety.
3. Bad Character enumeration.
4. Locations of return address need to be places programatically reachable else you probably should have check this in prefixing part 1.
5. Double check the endianness of any additions
6. Be aware of how the language assign buffers  and string handling(string termination in C with 0x00) if you need to change size.

#### With  Memory Corrupt Protection
One day, one day. See [LiveOverflow](https://www.youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN)


## Heap based exploits
One day, one day. See [LiveOverflow](https://www.youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN)
#### Without  Memory Corrupt Protection

#### Without  Memory Corrupt Protection


## Timing Attack exploits


##  Fixing Web Exploits 




## References
[LiveOverFlow Playlist](https://www.youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN)
