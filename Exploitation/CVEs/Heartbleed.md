# Heartbleed -  CVE-2014-0160

The Heartbleed Bug is security bug in the OpenSSL's implementation of the TLS/DTLS ([transport layer security protocols](https://www.synopsys.com/software-integrity/security-testing/fuzz-testing/defensics.html)) heartbeat extension (RFC6520). When it is exploited it leads to the leak of memory contents from the server to the client and from the client to the server. It was introduced into the software in 2012 and publicly disclosed in April 2014. It is an implementation of SSL/TLS that leads to slow leaking of primary key material, secondary key material, protected content and collateral. So that is encryption keys that can be used to decrypt traffic, user credential that be used to impersonate a user, the protected content that the encryption is implemented to secure and final any collateral information for indentifying the machine state technical and security related. See [[SSL-TLS]].

The implementation error occurs in the aforemention heartbeat message used to keep the connection alive even when no data is sent between client and server. Client-Server re-establishing connection, negocitating encryption and handling keys is data expensive - meaning higher latency. Heartbeat message is random data sent back and forth to make sure both parties remain connected.

```c
// Struct used by the function dtls1_process_heartbeat to handle heartbeats that keep the ssl connection alive
typedef struct ssl3_record_st
	{
/*r */	int type;               /* type of record */
/*rw*/	unsigned int length;    /* How many bytes available */
/*r */	unsigned int off;       /* read/write offset into 'buf' */
/*rw*/	unsigned char *data;    /* pointer to the record data */
/*rw*/	unsigned char *input;   /* where the decode bytes are */
/*r */	unsigned char *comp;    /* only used with decompression - malloc()ed */
/*r */  unsigned long epoch;    /* epoch number, needed by DTLS1 */
/*r */  PQ_64BIT seq_num;       /* sequence number, needed by DTLS1 */
/*rw*/	unsigned int orig_len;  /* How many bytes were available before padding
				   was removed? This is used to implement the
				   MAC check in constant time for CBC records.
				 */
	} SSL3_RECORD;

//first byte of SSL record is the type stub of the heartbeat received
//macro n2s(p, payload) is two bytes from p concatenating both p and type stub into payload
int dtls1_process_heartbeat(SSL *s)
	{
	unsigned char *p = &s->s3->rrec.data[0], *pl;
	unsigned short hbtype;
	unsigned int payload;
	unsigned int padding = 16; /* Use minimum padding */
    
    /* Read type and payload length first */
    hbtype = *p++;
    n2s(p, payload);
    pl = p;
//THE LENGTH OF THE SSL record is NOT VERIFIED
// pl now points to the heartbeat datat which was sent by client

unsigned char *buffer, *bp;
int r;

/* Allocate memory for the response, size is 1 byte
 * message type, plus 2 bytes payload length, plus
 * payload, plus padding
 */
buffer = OPENSSL_malloc(1 + 2 + payload + padding);
bp = buffer;

//s2n move payload size to bp a buffer and memcpy COPYING THE NUMBER OF BYTES REQUESTED
s2n(payload, bp);
memcpy(bp, pl, payload);

//payload can be a maximum vlue of 65535 or 64k - the amount of MEMORY the client wants
//User defined allocation of data selected to be transmitted, which can be resoureced from the 
//SURROUNDING MEMORY ADDRESSES that then contain memory address holding credentials, keys, etc

```

So the server creates a pointer to the heartbeat record in memory, copies the length of the data sent by the user into payload variable - length is unchecked allowing for surround memory to copied in a buffer which is then sent.


## Remeditation
1.  The server needs to check that the length of the heartbeat message sent by the user isn’t 0    
2. The server needs to check the the length doesn’t exceed the specified length of the variable that holds the data


## References

[THM Room](https://tryhackme.com/room/heartbleed)
[Heartbleed Wiki](https://en.wikipedia.org/wiki/Heartbleed)
[Heartbleed Bug special site](https://heartbleed.com/)
[Stackabuse Explaination](https://stackabuse.com/heartbleed-bug-explained/)
[Sean Cassidy Blog](https://www.seancassidy.me/diagnosis-of-the-openssl-heartbleed-bug.html)