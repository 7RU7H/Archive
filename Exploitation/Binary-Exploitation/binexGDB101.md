
# This is currently this is just me building blocks of an idiot Beware





If fortunate enough, gdb will do


ldd bin	# CHECK for libc and other commonailities need to reverse 


## PLACES AND CONCEPTS  OF INTEREST






## ASLR check

```bash
cat /proc/sys/kernel/randomize_va_space
```
BUT when exploiting clib functions, or any libraries .. 
BEWARE OF YOUR LACK OF KNOWLEDGE PER BOX!
WHERE  IS?:
1. THE FUNCTION IS IN ADDRESS SPACE OR FUNCTION POINTER ADDRESSES, etc..

RECONINT = 

GDB:

pattern create //with gef plugin for gdb
// if 32bit search $rip, 64 bit $rsp 
pattern search $rsp //also guesses endianess aswell as offset



This is with PWNTOOLS


from within bin-disassembler
```bash
cyclic $int #  pwntools pattern creation function
cyclic_find  # pwntools pattern offset search function
```

// from remote box, remote exploit script 
connect = remote('IP' port)
// pwntools shell coding
shellcraft

run | r 
(COPY+PASTE FUZZER)
info register
x/100x $rsp
x/100x $rsp-$RECONINT






## APPENDIX:

\xCC as a graceful break for binex than crashing.

// ENDIANNESS tester
```c
#include <stdio.h>
union s{
	int n;
	char b;
}x;
void main(){
	x.n = 0x4142;
	if(x.b == 0x42){
		printf("Little Endian\n");
	}
	else{
		printf("Big Endian\n");
	}
}
```


```go
bof := strings.Builder{}
shell := ` `

offset := 608
rip := '0x' //store it to not overflow your own memory
formatRIP := //nice formatting hex function
nopSled := `\x90` 
safeJunk := `\xCC`
* someamount
payloadSize := offset + 8
shellSize := len(shell)
nopSize := len(nopSled)
padding := 'A' * (payloadSize - shellSize - nopSize)

bof.WriteString(nopSled, shell, padding, formatRIP)

payload := bof.String()

fmt.Printf("%s", payload)
```
