Return Oriented Programming (ROP) is using small bits of code that exist in the program to take little steps towards getting what you want to happen.

## Disassemble

Find the functions 

Ghidra - blue linked function not in binary

## Debugger 

```bash
gef> r # run binary
# 
gef> pattern create <size>
# copy and paste 
r <paste pattern at correct stage of the program>
# look at *sp register address 
gef> pattern search $string_in_rsp
# for rop chaining you need the address of function call found in an disassembler
# how many arguments does the function call take?
gef> info functions
# There are many way to go about using the function calls avaliable
# be mindful of:
# what any of the functions does
# arguments amount and type of that function
# whether the function is linked or not
# what address is it called from
gef> b *$function_call_address # requires *
# beware Arch!
# x64 order of execution of variables - rdi rsi rsx rcx r8 r9
x/s $register(s)_of_loaded_variables # the parametre of function call
# Now find away to hijack with your own string
gef> ropper --search r$num # for legacy-gef or gef-extras
ropper -f $binary | grep $register_of_the_function # from commandline
# or 
objdump -D $binary  | grep -i $function_name
``` 


## Pwntools skeleton script

[[Pwntools]]