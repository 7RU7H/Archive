# Server-Side Request Forgery

Server-Side Request Forgery (SSRF), [PortSwigger](https://portswigger.net/web-security/ssrf) states: *"is a web security vulnerability that allows an attacker to cause the server-side application to make requests to an unintended location."*

Impact:
- Access to data within an organisation - data exposure
- Reconnaissance of internal network 
- Potential arbitrary command execution  
- Denial or Service Attacks

- Definitions for help
		- In-Band: directly receiving responses from a target
		- Out-of-band: not directly receiving responses from a target


- Types
	- Reflected
		- Cause an application to issue a back-end HTTP request to a supplied URL and then the response from the back-end request is returned in the application's front-end response
	- Blind 
		- *Cause an application to issue a back-end HTTP request to a supplied URL, but the response from the back-end request is not returned in the application's front-end response*?
		- Note from [Portswigger](https://portswigger.net/web-security/ssrf/blind) *It is common when testing for SSRF vulnerabilities to observe a DNS look-up for the supplied Collaborator domain, but no subsequent HTTP request. This typically happens because the application attempted to make an HTTP request to the domain, which caused the initial DNS lookup, but the actual HTTP request was blocked by network-level filtering. It is relatively common for infrastructure to allow outbound DNS traffic, since this is needed for so many purposes, but block HTTP connections to unexpected destinations.*
		- Techniques:
			- Use out-of-band techniques = attempt to trigger an HTTP request to an external system that you control
				- `python3 -m http.server 80` or beware DNS blacklisting!
				- `BurpSuite Collaborator`
			- *Explore content on systems that the application server can reach*, because their is DNS blacklisting
				- blindly sweep the internal IP address space
			- *Induce the application to connect to a system under the attacker's control, and return malicious responses to the HTTP client that makes the connection.* RCEs!	 
- Locale	
	- Affecting the local server
		- Why implicitly trust request that come directly from the local machine:
			- *The [access control](https://portswigger.net/web-security/access-control) check might be implemented in a different component that sits in front of the application server. When a connection is made back to the server, the check is bypassed.*
			- Disaster recovery may require administrative access without authentication from the local machine
				- Assumption of trust the user would come directly from the server
			- Administrative interface might listen on a different port to the main application - not reachable directly by users. 
	- Affecting back-end systems
		- Protected by network topology (often non-routable private IP address), but weaker security posture
- Indicators:
	- Full URL used in a parameter in address bar
	- Hidden field in a form
	- Partial URL as just a `hostname`
	- Path of a URL 
- Bypassing SSRF defences
	- SSRF Blacklist-based input filters
		- Alternate IP representations
		- Registering a domain that resolves to `127.0.0.1` - `spoofed.burpcollaborator.net`
		- Obfuscate blocked strings using URL encoding, case variation
		- Provide a controlled URL that redirects to the target URL
			- Try different:
				- Redirection codes
				- Protocols 
	- SSRF Whitelist-based input filters 
		- Combinations of or singularly (exploitation of inconsistencies in URL):
			- Embedded credentials using `@`
			- URL fragments `#` `https://url#expected-host`
			- Leverage DNS naming hierarchy with controlled FQDN `https://expected-host.evil-host`
			- URL encoding characters to confuse the URL-parsing code (especially if there is asymmetry in how the filter handles URL encoded characters to the code that executes the back-end request)
				- Double encoding
	- SSRF Bypassing filter via [open redirect](https://learn.snyk.io/lesson/open-redirect/) a *vulnerability occurs when an application allows a user to control a redirect or forward to another URL*
		- API used to make the back-end HTTP request supports redirection 
		- The parameter has to actually redirect, because the 
		- Construct a URL that satisfies the filter to then redirected to your defined destination
- Hidden Attack Surface
	- Partial URLs in requests
		- Some *applications places only a hostname or part of a URL path into request parameters.*
			- *However full SSRF might be limited because you do not control the entire URL that gets requested.*	-
		- URLs within data formats
			- Some applications transmit data in formats with a specification that allows the inclusion of URLs that might get requested by the data parser for the format.
			- examples: 
				- SSRF to reach an XML parser to perform [[XXE-Injection]] 
				- SSRF via  [[XXE-Injection]] if URL is modifiable within the XML 
	- SSRF via Referrer header
		- *Some applications use server-side analytics software to tracks visitors. This software often logs the Referrer header in requests, so it can track incoming links. Often the analytics software visits any third-party URLs that appear in the Referrer header.*


## Considerations

- Access sensitive files
- Portsweep internal services on `127.0.0.1`
- Attack services through the SSRF with another vulnerability 

- By Language:
	- PHP
		- [[Useful_PHP]] - [[PHP-Filters]] including `file:///filepath/to/file.php` to 
		- In combination [[File-Inclusion]] if `include()` is used

## Mitigation

- Deny List - THM says no PortSwigger says both!
- Allow List - THM says just an Allow list  PortSwigger says both!
- Open redirect 
- Input Validation
- Network segregation for internal resources
- Implement security headers
- Strong access controls for internal resources
- Logging and monitoring to track SSRF-like requests to internal resources

## References

[PortSwigger SSRF](https://portswigger.net/web-security/ssrf) 
[PortSwigger Access Control](https://portswigger.net/web-security/access-control)
[THM Room SSRF](https://tryhackme.com/room/ssrfqi)
[Snyk open redirect](https://learn.snyk.io/lesson/open-redirect/) 
[Portswigger](https://portswigger.net/web-security/ssrf/blind)
[THM Room: SSRF -inner workings of SSRF ](https://tryhackme.com/room/ssrfhr) 
## Appendix

Improved code from [THM Room: SSRF -inner workings of SSRF ](https://tryhackme.com/room/ssrfhr) :
```python
import os, glob, argparse, sys, signal
from http.server import SimpleHTTPRequestHandler, HTTPServer
from urllib.parse import unquote

# Moddified code from https://tryhackme.com/room/ssrfhr 
# Added more secure interface handling
# Write Data to stdout with verbose
# 

class CustomRequestHandler(SimpleHTTPRequestHandler):

    def end_headers(self):
        self.send_header('Access-Control-Allow-Origin', '*')  # Allow requests from any origin
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        super().end_headers()

    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        content_length = self.headers.get('Content-Length')
        if content_length != None:
            content_length = int(content_length)
            get_data = self.rfile.read(content_length).decode('utf-8')
        else:
            get_data = ''
        
        self.wfile.write(b'So long, and thanks for all the GET requests')
        get_data = self.rfile.read(content_length).decode('utf-8')
        if global_verbose:
             print(f'We have recieved a GET request!\nReceived data:\{get_data}')
        
        filename = self.generate_valid_filename('get')
        with open(filename, 'w') as file:
            file.write(get_data + '\n')
            print(f"GET data written to {filename}")
		
	
    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length).decode('utf-8')
        self.send_response(200)
        self.end_headers()

        if global_verbose:
            print(f'We have recieved a POST request!\nReceived data:\n{post_data}')
        
        filename = self.generate_valid_filename('post')
        with open('post_data.html', 'a') as file:
            file.write(post_data + '\n')
            print(f"POST data written to {filename}")

    def generate_valid_filename(self, prefix, extension=".html"):
        i = 1
        while True:
            filename = f"{prefix}_data_{i}{extension}"
            if not os.path.exists(filename):
                return filename
            i += 1

def signal_handler(sig, frame):
    print("You pressed CTRL+C!")
    print("Happy Hacking!")
    sys.exit(0)

# This is very dirty, but works will happily accept improvements to this:
global_verbose = False 

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Python3 - Data Receiver - Just Gift your data to please the server!')
    parser.add_argument('-v', action='store_true', default=False, help='Print output to stdout')
    parser.add_argument('-i', type=str, default='127.0.0.1', help='Interface to bind to')
    parser.add_argument('-p', type=int, default=8000, help='Port to listen on')
    args = parser.parse_args()
    # Gloriously bad
    if args.v != False:
        global_verbose = True

    signal.signal(signal.SIGINT, signal_handler)
    server_address = (args.i, args.p)
    httpd = HTTPServer(server_address, CustomRequestHandler)
    print(f"Server running on http://{args.i}:{args.p}/")
    httpd.serve_forever()

```
